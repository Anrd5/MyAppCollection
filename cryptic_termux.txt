#!/usr/bin/env bash
# install_cryptics_daemon.sh
# One-shot installer + dual-trigger background daemon.
# Features:
# - Auto APK installs via root (from RefreshClones.txt)
# - Remote update of JSON config (from RefreshScript.txt)
# - Foreground/daemon support, PID/logfile, KEEP_APKS, --test mode

set -u

# --- Configurable ENV ---
WORKDIR="${WORKDIR:-$HOME/cryptic_apks}"
KEEP_APKS="${KEEP_APKS:-0}"
POLL_INTERVAL="${POLL_INTERVAL:-30}"
TRIGGER_URL="${TRIGGER_URL:-https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/RefreshClones.txt}"
STATE_FILE="${WORKDIR}/.last_refresh_state"
PIDFILE_DEFAULT="${WORKDIR}/cryptic_daemon.pid"
LOGFILE_DEFAULT="${HOME}/cryptic_daemon.log"

# SpeedHubX
JSON_TRIGGER_URL="${JSON_TRIGGER_URL:-https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshScript.txt}"
CONFIG_URL="${CONFIG_URL:-https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json}"
TARGET_JSON="${TARGET_JSON:-/storage/emulated/0/Cryptic/Workspace/SpeedHubX/Grow a Garden.json}"
STATE_FILE_JSON="${WORKDIR}/.last_refresh_json_state"

# --- APK Links ---
LINKS=(
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# --- CLI Args ---
DAEMONIZE=0
TEST_MODE=0
PIDFILE=""
LOGFILE=""

usage() {
cat <<EOF
Usage: $0 [OPTIONS]

Options:
  --daemonize           Background mode (nohup + log + PID)
  --pidfile <path>      PID file (default: ${PIDFILE_DEFAULT})
  --logfile <path>      Log file (default: ${LOGFILE_DEFAULT})
  --test                Download/install only first APK and exit
  --help                Show this help

Environment:
  WORKDIR, KEEP_APKS, POLL_INTERVAL, TRIGGER_URL
  JSON_TRIGGER_URL, CONFIG_URL, TARGET_JSON

Example:
  POLL_INTERVAL=10 KEEP_APKS=1 $0 --daemonize --logfile /sdcard/cryptic_log.txt
EOF
}

i=1
while [ $i -le $# ]; do
  arg="${!i}"
  case "$arg" in
    --daemonize) DAEMONIZE=1 ;;
    --pidfile) i=$((i+1)); PIDFILE="${!i:-}";;
    --logfile) i=$((i+1)); LOGFILE="${!i:-}";;
    --test) TEST_MODE=1 ;;
    --help|-h) usage; exit 0 ;;
    *) echo "Unknown option: $arg"; usage; exit 1 ;;
  esac
  i=$((i+1))
done

PIDFILE="${PIDFILE:-$PIDFILE_DEFAULT}"
LOGFILE="${LOGFILE:-$LOGFILE_DEFAULT}"

mkdir -p "$WORKDIR"
cd "$WORKDIR" || exit 1

log() { printf '[%s] %s\n' "$(date)" "$*"; }

if [ "$DAEMONIZE" = 1 ]; then
  if [ -f "$PIDFILE" ]; then
    oldpid="$(cat "$PIDFILE" 2>/dev/null || true)"
    if [ -n "$oldpid" ] && kill -0 "$oldpid" 2>/dev/null; then
      echo "Daemon already running (PID $oldpid)."; exit 0
    fi
    rm -f "$PIDFILE"
  fi
  mkdir -p "$(dirname "$LOGFILE")"
  nohup "$0" --pidfile "$PIDFILE" --logfile "$LOGFILE" > "$LOGFILE" 2>&1 &
  echo "$!" > "$PIDFILE"
  echo "Daemon started. PID: $! Log: $LOGFILE"
  exit 0
fi

echo "$$" > "$PIDFILE"
trap 'rm -f "$PIDFILE"; log "Exiting"; exit 0' SIGINT SIGTERM EXIT

# --- Downloader ---
DL_TOOL=""
command -v wget >/dev/null && DL_TOOL="wget"
command -v curl >/dev/null && DL_TOOL="${DL_TOOL:-curl}"
if [ -z "$DL_TOOL" ]; then
  pkg update -y && pkg install -y wget
  command -v wget >/dev/null && DL_TOOL="wget"
  command -v curl >/dev/null && DL_TOOL="${DL_TOOL:-curl}"
fi
log "Using downloader: $DL_TOOL"

download_file() {
  local url="$1" out="$2"
  [ "$DL_TOOL" = "wget" ] && wget -c -O "$out" "$url" || curl -L -C - -o "$out" "$url"
}

fetch_flag() {
  local url="$1"
  local txt
  [ "$DL_TOOL" = "wget" ] && txt="$(wget -qO- "$url" 2>/dev/null)" || txt="$(curl -fsSL "$url" 2>/dev/null)"
  printf '%s' "$txt" | tr -d '[:space:]' | cut -c1
}

# --- Root command ---
ROOT_CMD=""
command -v tsu >/dev/null && ROOT_CMD="tsu --"
command -v su >/dev/null && ROOT_CMD="${ROOT_CMD:-su -c}"
[ -z "$ROOT_CMD" ] && log "No root helper (tsu/su) found. APK installs will fail."

install_apk_root() {
  local apk="$1"
  [ -n "$ROOT_CMD" ] && $ROOT_CMD pm install -r -g "$apk"
}

# --- APK install ---
do_downloads_and_installs() {
  log "Starting APK downloads..."
  for url in "${LINKS[@]}"; do
    fname="${url##*/}"
    [ -f "$fname" ] && [ ! -s "$fname" ] && rm -f "$fname"
    log "Downloading $fname"
    download_file "$url" "$fname"
    [ ! -s "$fname" ] && log "$fname is empty. Skipping." && continue
    install_apk_root "$PWD/$fname"
    if [ $? -eq 0 ]; then
      log "Installed $fname"
      [ "$KEEP_APKS" = "0" ] && rm -f "$fname"
    else
      log "Failed to install $fname"
    fi
  done
  log "APK install complete."
}

# --- SpeedHubX JSON sync ---
sync_json_config() {
  log "Refreshing SpeedHubX config..."
  tmp="$WORKDIR/tmp_config.json"
  download_file "$CONFIG_URL" "$tmp"
  [ ! -s "$tmp" ] && log "Empty config. Skipping." && return
  cp "$tmp" "$TARGET_JSON" && log "Updated: $TARGET_JSON"
  rm -f "$tmp"
}

# --- TEST mode ---
if [ "$TEST_MODE" = 1 ]; then
  LINKS=("${LINKS[0]}")
  do_downloads_and_installs
  exit 0
fi

# --- Daemon loop ---
last_state=""
last_json=""
[ -f "$STATE_FILE" ] && last_state="$(cat "$STATE_FILE")"
[ -f "$STATE_FILE_JSON" ] && last_json="$(cat "$STATE_FILE_JSON")"

log "Daemon running. Poll every ${POLL_INTERVAL}s"

while true; do
  # APK trigger
  remote="$(fetch_flag "$TRIGGER_URL")"
  if [ "$remote" != "$last_state" ]; then
    log "APK trigger: $last_state → $remote"
    [ "$remote" = "1" ] && do_downloads_and_installs
    echo "$remote" > "$STATE_FILE"; last_state="$remote"
  fi

  # JSON trigger
  json_flag="$(fetch_flag "$JSON_TRIGGER_URL")"
  if [ "$json_flag" != "$last_json" ]; then
    log "JSON trigger: $last_json → $json_flag"
    [ "$json_flag" = "1" ] && sync_json_config
    echo "$json_flag" > "$STATE_FILE_JSON"; last_json="$json_flag"
