#!/usr/bin/env bash
# install_cryptics_daemon.sh
# One-shot installer + continuous daemon that polls remote triggers.
# Now also updates a local JSON on a separate trigger.
# - Handles GitHub blob links by auto-converting to raw.
# - Separate state files for APKs and JSON config.
# - Daemonizes cleanly; safe to use Termux for other scripts concurrently.
set -u

# ----------------- Configuration (can be overridden with env vars) -----------------
WORKDIR="${WORKDIR:-$HOME/cryptic_apks}"
KEEP_APKS="${KEEP_APKS:-0}"                     # set KEEP_APKS=1 to keep apk files
POLL_INTERVAL="${POLL_INTERVAL:-30}"            # seconds between trigger checks

# TRIGGERS (blob or raw supported; auto-rawified)
APK_TRIGGER_URL_DEFAULT="https://github.com/Anrd5/MyAppCollection/blob/main/RefreshClones.txt"
CONFIG_TRIGGER_URL_DEFAULT="https://github.com/Anrd5/MyAppCollection/blob/main/RefreshScript.txt"

APK_TRIGGER_URL="${APK_TRIGGER_URL:-${TRIGGER_URL:-$APK_TRIGGER_URL_DEFAULT}}"
CONFIG_TRIGGER_URL="${CONFIG_TRIGGER_URL:-$CONFIG_TRIGGER_URL_DEFAULT}"

# CONFIG COPY (source is the release asset; we just copy its text to the local JSON)
CONFIG_SOURCE_URL="${CONFIG_SOURCE_URL:-https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json}"

# Target local file (quotes/space-safe). You can override if your filename differs.
CONFIG_TARGET_PATH="${CONFIG_TARGET_PATH:-/storage/emulated/0/Cryptic/Workspace/SpeedHubX/Grow a Garden.json}"

# State files and daemon files
APK_STATE_FILE="${WORKDIR}/.last_apk_state"
CONFIG_STATE_FILE="${WORKDIR}/.last_config_state"
PIDFILE_DEFAULT="${WORKDIR}/cryptic_daemon.pid"
LOGFILE_DEFAULT="${HOME}/cryptic_daemon.log"

# ----------------- The APK links (unchanged) -----------------
LINKS=(
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
"https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# ----------------- CLI parsing -----------------
DAEMONIZE=0
TEST_MODE=0
PIDFILE=""
LOGFILE=""

usage() {
  cat <<EOF
Usage: $0 [OPTIONS]

Options:
  --daemonize           Run as background daemon (nohup -> logfile; writes PID)
  --pidfile <path>      Specify PID file (default: ${PIDFILE_DEFAULT})
  --logfile <path>      Specify logfile (default: ${LOGFILE_DEFAULT})
  --test                Test mode: download & install only the first APK once, then exit
  --help                Show this help and exit

Environment variables:
  WORKDIR, KEEP_APKS, POLL_INTERVAL
  APK_TRIGGER_URL, CONFIG_TRIGGER_URL
  CONFIG_SOURCE_URL, CONFIG_TARGET_PATH

Examples:
  $0 --test
  $0 --daemonize
  POLL_INTERVAL=10 KEEP_APKS=1 $0 --daemonize --logfile /sdcard/cryptic_log.txt
EOF
}

i=1
while [ $i -le $# ]; do
  arg="${!i}"
  case "$arg" in
    --daemonize) DAEMONIZE=1 ;;
    --pidfile) i=$((i+1)); PIDFILE="${!i:-}";;
    --logfile) i=$((i+1)); LOGFILE="${!i:-}";;
    --test) TEST_MODE=1 ;;
    --help|-h) usage; exit 0 ;;
    *) echo "Unknown option: $arg"; usage; exit 1 ;;
  esac
  i=$((i+1))
done

PIDFILE="${PIDFILE:-$PIDFILE_DEFAULT}"
LOGFILE="${LOGFILE:-$LOGFILE_DEFAULT}"

# ----------------- Helpers -----------------
mkdir -p "$WORKDIR"
cd "$WORKDIR" || { echo "ERROR: cannot cd to $WORKDIR"; exit 1; }

log() { printf '[%s] %s\n' "$(date --iso-8601=seconds 2>/dev/null || date)" "$*"; }

rawify_url() {
  # Converts GitHub 'blob' URL to raw.githubusercontent.com; leaves others unchanged.
  # Example: https://github.com/user/repo/blob/branch/path -> https://raw.githubusercontent.com/user/repo/branch/path
  local u="$1"
  case "$u" in
    https://github.com/*/blob/*)
      # shellcheck disable=SC2001
      printf '%s' "$u" | sed -e 's#https://github.com/#https://raw.githubusercontent.com/#' -e 's#/blob/#!/#'
      ;;
    *)
      printf '%s' "$u"
      ;;
  esac
}

# Daemonize: parent launches child with nohup and exits
if [ "$DAEMONIZE" = 1 ]; then
  if [ -f "$PIDFILE" ]; then
    oldpid="$(cat "$PIDFILE" 2>/dev/null || true)"
    if [ -n "$oldpid" ] && kill -0 "$oldpid" 2>/dev/null; then
      echo "Daemon already running (PID $oldpid). Exiting."
      exit 0
    else
      rm -f "$PIDFILE" 2>/dev/null || true
    fi
  fi
  mkdir -p "$(dirname "$LOGFILE")" 2>/dev/null || true
  nohup "$0" --pidfile "$PIDFILE" --logfile "$LOGFILE" > "$LOGFILE" 2>&1 &
  childpid=$!
  echo "$childpid" > "$PIDFILE"
  echo "Started daemon (PID $childpid). Log: $LOGFILE  PID: $PIDFILE"
  exit 0
fi

# If running (foreground/child) write PID file
printf '%s' "$$" > "$PIDFILE" 2>/dev/null || true
trap 'if [ -f "$PIDFILE" ] && [ "$(cat "$PIDFILE" 2>/dev/null)" = "$$" ]; then rm -f "$PIDFILE"; fi; log "Exiting"; exit 0' SIGINT SIGTERM EXIT

# ----------------- Downloader selection -----------------
DL_TOOL=""
if command -v wget >/dev/null 2>&1; then
  DL_TOOL="wget"
elif command -v curl >/dev/null 2>&1; then
  DL_TOOL="curl"
else
  log "No wget/curl found. Attempting to install wget via pkg..."
  pkg update -y >/dev/null 2>&1 || true
  pkg install -y wget >/dev/null 2>&1 || true
  if command -v wget >/dev/null 2>&1; then
    DL_TOOL="wget"
  elif command -v curl >/dev/null 2>&1; then
    DL_TOOL="curl"
  else
    log "Failed to obtain wget/curl. Install one and re-run."
    exit 1
  fi
fi
log "Using downloader: $DL_TOOL"

# ----------------- Root helper -----------------
ROOT_CMD=""
if command -v tsu >/dev/null 2>&1; then
  ROOT_CMD="tsu --"
elif command -v su >/dev/null 2>&1; then
  ROOT_CMD="su -c"
else
  log "No root helper (tsu or su) found. Script requires root to install silently."
  log "Install tsu (pkg install tsu) or ensure su is available, then re-run."
  exit 1
fi
log "Using root command: ${ROOT_CMD%% *}"

# ----------------- Core functions -----------------
download_file() {
  local url="$1"
  local out="$2"
  if [ "$DL_TOOL" = "wget" ]; then
    wget -c -O "$out" "$url"
  else
    curl -L -C - -o "$out" "$url"
  fi
}

fetch_text_to_stdout() {
  local url="$1"
  if [ "$DL_TOOL" = "wget" ]; then
    wget -qO- "$url" 2>/dev/null || true
  else
    curl -fsSL "$url" 2>/dev/null || true
  fi
}

install_apk_root() {
  local apk_path="$1"
  if command -v tsu >/dev/null 2>&1; then
    tsu pm install -r -g "$apk_path"
  else
    su -c "pm install -r -g '$apk_path'"
  fi
}

get_remote_flag() {
  local src_url="$1"
  local url="$(rawify_url "$src_url")"
  local content=""
  content="$(fetch_text_to_stdout "$url")"
  content="$(printf '%s' "$content" | tr -d ' \t\r\n' | cut -c1 || true)"
  case "$content" in
    0|1) printf '%s' "$content" ;;
    *) printf '' ;;
  esac
}

# ----------------- APK downloads/installs -----------------
do_downloads_and_installs() {
  log "Starting downloads and installs into $WORKDIR"
  log "----"
  for url in "${LINKS[@]}"; do
    fname="${url##*/}"
    log "Processing: $fname"
    if [ -f "$fname" ] && [ ! -s "$fname" ]; then
      log "Removing zero-size stale file $fname"
      rm -f "$fname"
    fi

    log "Downloading from: $url"
    if ! download_file "$url" "$fname"; then
      log "Error: download failed for $fname. Skipping."
      continue
    fi

    if [ ! -s "$fname" ]; then
      log "Downloaded file is empty. Skipping install for $fname."
      continue
    fi

    size_bytes=$(stat -c%s "$fname" 2>/dev/null || ls -l "$fname" | awk '{print $5}')
    log "Downloaded $fname (${size_bytes} bytes). Installing..."
    if install_apk_root "$PWD/$fname"; then
      log "Installed $fname successfully."
      if [ "$KEEP_APKS" = "0" ]; then
        log "Removing $fname to save space..."
        rm -f "$fname"
      else
        log "Keeping $fname as requested (KEEP_APKS=1)."
      fi
    else
      log "Warning: installation failed for $fname. File kept for debugging."
    fi
  done
  log "All APK tasks finished. Workdir: $WORKDIR"
}

# ----------------- Config updater (JSON copy) -----------------
find_config_target_path() {
  # Tries given path; if not present, tries common case variants. Returns chosen path.
  # We will write to the requested path regardless; but this helps if existing file uses 'A' uppercase.
  local default="$1"
  local base_dir
  base_dir="$(dirname "$default")"
  local name_default="$(basename "$default")"
  local alt1="Grow a Garden.json"
  local alt2="Grow A Garden.json"

  if [ -f "$base_dir/$name_default" ]; then printf '%s' "$base_dir/$name_default"; return; fi
  if [ -f "$base_dir/$alt1" ]; then printf '%s' "$base_dir/$alt1"; return; fi
  if [ -f "$base_dir/$alt2" ]; then printf '%s' "$base_dir/$alt2"; return; fi
  # Fallback to default path
  printf '%s' "$default"
}

do_config_update() {
  local source_url_raw="$(rawify_url "$CONFIG_SOURCE_URL")"   # release URL is already direct, but harmless
  local target_dir
  target_dir="$(dirname "$CONFIG_TARGET_PATH")"
  local target_path
  target_path="$(find_config_target_path "$CONFIG_TARGET_PATH")"

  if [ ! -d "$target_dir" ]; then
    log "Config target directory missing: $target_dir"
    log "Ensure you ran: termux-setup-storage, and that the path exists."
    return 1
  fi

  local tmp="${WORKDIR}/.config_download.tmp"
  log "Fetching config from: $source_url_raw"
  if ! download_file "$source_url_raw" "$tmp"; then
    log "Config download failed. Will not modify local JSON."
    rm -f "$tmp" 2>/dev/null || true
    return 1
  fi

  if [ ! -s "$tmp" ]; then
    log "Downloaded config is empty. Aborting update."
    rm -f "$tmp" 2>/dev/null || true
    return 1
  fi

  # Backup existing file if present
  if [ -f "$target_path" ]; then
    local ts
    ts="$(date +%Y%m%d_%H%M%S 2>/dev/null || date +%s)"
    local bak="${target_path}.bak.${ts}"
    if cp -f "$target_path" "$bak" 2>/dev/null; then
      log "Backed up existing JSON to: $bak"
    else
      log "Warning: could not back up existing JSON."
    fi
  fi

  # Overwrite with new content
  if cp -f "$tmp" "$target_path" 2>/dev/null; then
    log "Updated JSON: $target_path"
  else
    log "Failed to write JSON to $target_path (permissions?)."
    rm -f "$tmp" 2>/dev/null || true
    return 1
  fi
  rm -f "$tmp" 2>/dev/null || true
  return 0
}

# ----------------- TEST mode -----------------
if [ "$TEST_MODE" = 1 ]; then
  log "TEST MODE: only downloading + installing the first APK once."
  if [ ${#LINKS[@]} -gt 0 ]; then
    first="${LINKS[0]}"
    LINKS=("$first")
  fi
  do_downloads_and_installs
  exit 0
fi

# ----------------- Daemon loop: watch two triggers -----------------
last_apk_state=""
last_config_state=""

[ -f "$APK_STATE_FILE" ] && last_apk_state="$(cat "$APK_STATE_FILE" 2>/dev/null || true)"
[ -f "$CONFIG_STATE_FILE" ] && last_config_state="$(cat "$CONFIG_STATE_FILE" 2>/dev/null || true)"

log "Daemon starting."
log "Polling APK trigger:    $(rawify_url "$APK_TRIGGER_URL") every ${POLL_INTERVAL}s (initial: '${last_apk_state:-}')"
log "Polling CONFIG trigger: $(rawify_url "$CONFIG_TRIGGER_URL") every ${POLL_INTERVAL}s (initial: '${last_config_state:-}')"
log "Logfile: ${LOGFILE}"

while true; do
  # APK trigger
  remote_apk="$(get_remote_flag "$APK_TRIGGER_URL")"
  if [ -z "$remote_apk" ]; then
    log "APK trigger: warning: could not fetch remote flag (network or content)."
  elif [ "$remote_apk" != "$last_apk_state" ]; then
    log "APK trigger changed: '$last_apk_state' -> '$remote_apk'"
    if [ "$remote_apk" = "1" ]; then
      do_downloads_and_installs
    else
      log "APK trigger is '0' — idle."
    fi
    printf '%s' "$remote_apk" > "$APK_STATE_FILE"
    last_apk_state="$remote_apk"
  fi

  # CONFIG trigger
  remote_cfg="$(get_remote_flag "$CONFIG_TRIGGER_URL")"
  if [ -z "$remote_cfg" ]; then
    log "CONFIG trigger: warning: could not fetch remote flag (network or content)."
  elif [ "$remote_cfg" != "$last_config_state" ]; then
    log "CONFIG trigger changed: '$last_config_state' -> '$remote_cfg'"
    if [ "$remote_cfg" = "1" ]; then
      do_config_update
    else
      log "CONFIG trigger is '0' — idle."
    fi
    printf '%s' "$remote_cfg" > "$CONFIG_STATE_FILE"
    last_config_state="$remote_cfg"
  fi

  sleep "$POLL_INTERVAL"
done
