#!/data/data/com.termux/files/usr/bin/bash
# cryptic-manager.sh — Termux standalone orchestrator
# Android 10 (VMOS Cloud, rooted via Magisk) compatible.

set -Eeuo pipefail

# ------------ Configuration ------------

# APK sources (direct download links)
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# JSON source and target
JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"
JSON_TARGET_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
JSON_TARGET_FILE="${JSON_TARGET_DIR}/Grow a Garden.json"

# Trigger files (updated by GitHub Actions)
TRIGGER_APK_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/main/triggers/apk.trigger"
TRIGGER_JSON_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/main/triggers/json.trigger"

# Paths and state
APK_DIR="$HOME/apks"                # Keep APKs inside Termux private dir (SELinux-safe)
STATE_DIR="$HOME/.cryptic-manager"
LOG_FILE="$STATE_DIR/manager.log"
LOCK_FILE="$STATE_DIR/run.lock"
LAST_APK_TRIGGER="$STATE_DIR/last_apk.trigger"
LAST_JSON_TRIGGER="$STATE_DIR/last_json.trigger"
FIRST_RUN_FLAG="$STATE_DIR/.first_run"

# -------- Post-run external script (non-interference by default) --------
# By default, we DO NOT run any external script after tasks complete.
# If you want this manager to hand off control to your own script after it finishes,
# set POST_SCRIPT_ENABLE="true" and choose a mode:
#   - exec:      Cleanly release locks/wake and exec your command (manager fully replaced).
#   - supervise: Run your command and keep a tiny watcher that stops it if triggers change.
#
# The commands below mirror your example:
#   curl -L -o /sdcard/download/reconnect.lua http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT37PvJvFqYuVwX321098d1fgg
#   lua /sdcard/download/reconnect.lua
POST_SCRIPT_ENABLE="false"         # "true" to enable, "false" to disable (default)
POST_SCRIPT_MODE="exec"            # "exec" or "supervise"
POST_LUA_PATH="/sdcard/download/reconnect.lua"
POST_LUA_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT37PvJvFqYuVwX321098d1fgg"
POST_RUN_CMD=(lua "$POST_LUA_PATH")  # You can append args, e.g., (lua "$POST_LUA_PATH" reconnect.lua)

# ------------ Utilities ------------
ts() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }

log() { printf "[%s] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }

require_pkgs() {
  # Check specific binaries and install only what’s missing.
  local need_update=0
  has() { command -v "$1" >/dev/null 2>&1; }

  if ! has curl; then log "Installing package: curl"; pkg install -y curl >/dev/null 2>&1 || need_update=1; fi
  if ! has jq; then log "Installing package: jq"; pkg install -y jq >/dev/null 2>&1 || need_update=1; fi
  if ! has lua; then log "Installing package: lua"; pkg install -y lua >/dev/null 2>&1 || need_update=1; fi
  if ! has sha256sum; then log "Installing package: coreutils"; pkg install -y coreutils >/dev/null 2>&1 || need_update=1; fi
  if ! has flock; then log "Installing package: util-linux"; pkg install -y util-linux >/dev/null 2>&1 || need_update=1; fi

  if [ "$need_update" -eq 1 ]; then
    log "Refreshing package lists and retrying missing installs..."
    pkg update -y >/dev/null 2>&1 || true
    has curl || pkg install -y curl >/dev/null 2>&1 || log "WARNING: curl install failed"
    has jq || pkg install -y jq >/dev/null 2>&1 || log "WARNING: jq install failed"
    has lua || pkg install -y lua >/dev/null 2>&1 || log "WARNING: lua install failed"
    has sha256sum || pkg install -y coreutils >/dev/null 2>&1 || log "WARNING: coreutils install failed"
    has flock || pkg install -y util-linux >/dev/null 2>&1 || log "WARNING: util-linux install failed"
  fi
}

wake_lock_acquire() { if command -v termux-wake-lock >/dev/null 2>&1; then termux-wake-lock || true; fi; }
wake_lock_release() { if command -v termux-wake-unlock >/dev/null 2>&1; then termux-wake-unlock || true; fi; }

ensure_storage() {
  # Best-effort storage setup; Android UI still requires user tap.
  if [ ! -d /storage/emulated/0 ]; then
    log "Requesting storage access (termux-setup-storage)..."
    termux-setup-storage >/dev/null 2>&1 || true
    sleep 2
  fi
}

root_pm_install() {
  # Use root when available for reliable installs
  local apk_path="$1"
  if command -v su >/dev/null 2>&1; then
    su -c "pm install -r --user 0 \"$apk_path\"" >/dev/null
  else
    pm install -r "$apk_path" >/dev/null
  fi
}

download_file() {
  # $1=url $2=output
  local url="$1" out="$2"
  mkdir -p "$(dirname "$out")"
  curl -fL --retry 5 --retry-connrefused --retry-delay 2 --connect-timeout 15 -o "${out}.part" "$url"
  mv -f "${out}.part" "$out"
}

fetch_trigger() {
  # $1=url $2=state_file
  local url="$1" state="$2"
  local tmp cur_sum last_sum
  tmp="$(mktemp)"
  if curl -fsL --connect-timeout 10 "$url" -o "$tmp"; then
    cur_sum="$(sha256sum "$tmp" | awk '{print $1}')"
    if [ -f "$state" ]; then last_sum="$(cat "$state")"; else last_sum=""; fi
    if [ "$cur_sum" != "$last_sum" ] && [ -s "$tmp" ]; then
      echo "$cur_sum" >"$state"
      rm -f "$tmp"
      echo "changed"
      return 0
    fi
  fi
  rm -f "$tmp"
  echo "unchanged"
  return 0
}

# ------------ Tasks ------------
task_apks() {
  log "APK task: START"
  mkdir -p "$APK_DIR"
  local any_downloaded=0
  for url in "${APK_URLS[@]}"; do
    local name out
    name="$(basename "$url")"
    out="$APK_DIR/$name"
    log "Downloading: $name"
    download_file "$url" "$out"
    any_downloaded=1
  done

  if [ "$any_downloaded" -eq 1 ]; then
    for apk in "$APK_DIR"/*.apk; do
      [ -e "$apk" ] || continue
      log "Installing: $(basename "$apk")"
      if ! root_pm_install "$apk"; then
        log "ERROR: Install failed for $apk"
        rm -rf "$APK_DIR"
        exit 1
      fi
    done
  fi

  log "Cleaning APK cache"
  rm -rf "$APK_DIR"
  log "APK task: DONE"
}

task_json() {
  log "JSON task: START"
  ensure_storage
  mkdir -p "$JSON_TARGET_DIR"
  local tmp_json
  tmp_json="$(mktemp)"
  log "Downloading JSON: $(basename "$JSON_URL")"
  download_file "$JSON_URL" "$tmp_json"

  # Validate JSON before replacing
  if ! jq -e . <"$tmp_json" >/dev/null 2>&1; then
    log "ERROR: Downloaded JSON is invalid"
    rm -f "$tmp_json"
    exit 1
  fi

  # Atomic replace
  local tmp_target
  tmp_target="$(mktemp -p "$JSON_TARGET_DIR" "grow-XXXXXX.json")"
  cat "$tmp_json" >"$tmp_target"
  rm -f "$tmp_json"
  mv -f "$tmp_target" "$JSON_TARGET_FILE"
  chmod 0644 "$JSON_TARGET_FILE" 2>/dev/null || true

  log "JSON replaced at: $JSON_TARGET_FILE"
  log "JSON task: DONE"
}

# ------------ Post-run handoff (optional) ------------
cleanup_for_post_exec() {
  # Remove traps so post command is not affected
  trap - ERR EXIT
  # Release wakelock before exec (EXIT trap won't run on exec)
  wake_lock_release
  # Unlock and close the flock FD so post processes aren't blocked
  if command -v flock >/dev/null 2>&1; then flock -u 9 || true; fi
  exec 9>&- || true
}

prepare_post_payload() {
  # Download/update reconnect.lua at the desired path
  ensure_storage
  mkdir -p "$(dirname "$POST_LUA_PATH")"
  # Use resilient download but do not fail the whole manager if it errors
  if ! curl -fL --retry 5 --retry-delay 2 --connect-timeout 15 -o "${POST_LUA_PATH}.part" "$POST_LUA_URL"; then
    log "Post script: download failed (leaving previous file if present)"
    return 1
  fi
  mv -f "${POST_LUA_PATH}.part" "$POST_LUA_PATH"
  chmod 0644 "$POST_LUA_PATH" 2>/dev/null || true
  log "Post script: ready at $POST_LUA_PATH"
  return 0
}

supervise_until_trigger_changes() {
  # $1 = child_pid
  local child_pid="$1"
  log "Post script: watcher started (PID $child_pid)"
  # Poll both triggers and stop child if any changes are detected
  while kill -0 "$child_pid" >/dev/null 2>&1; do
    sleep 10
    local apk_change json_change
    apk_change="$(fetch_trigger "$TRIGGER_APK_URL" "$LAST_APK_TRIGGER")" || apk_change="unchanged"
    json_change="$(fetch_trigger "$TRIGGER_JSON_URL" "$LAST_JSON_TRIGGER")" || json_change="unchanged"
    if [ "$apk_change" = "changed" ] || [ "$json_change" = "changed" ]; then
      log "Post script: trigger change detected — stopping child (PID $child_pid)"
      kill "$child_pid" 2>/dev/null || true
      # Give it a moment to exit gracefully
      sleep 3
      kill -9 "$child_pid" 2>/dev/null || true
      break
    fi
  done
  log "Post script: watcher exiting"
}

run_post_handoff() {
  # Only called when no top feature ran this round AND POST_SCRIPT_ENABLE=true
  if ! prepare_post_payload; then
    log "Post script: skipped (prep failed)"
    return 0
  fi

  case "$POST_SCRIPT_MODE" in
    exec)
      log "Post script: exec mode — handing off and exiting manager"
      cleanup_for_post_exec
      # Replace manager with your command (no interference at all)
      exec "${POST_RUN_CMD[@]}"
      ;;
    supervise)
      log "Post script: supervise mode — starting child and watcher"
      # Start child first
      set +e
      "${POST_RUN_CMD[@]}" &
      local child_pid=$!
      set -e
      # Clean up manager footprint, then watch (no traps/wakelocks/locks)
      cleanup_for_post_exec
      supervise_until_trigger_changes "$child_pid"
      # When watcher exits, just end.
      exit 0
      ;;
    *)
      log "Post script: unknown mode '$POST_SCRIPT_MODE' — skipping"
      ;;
  esac
}

# ------------ Main ------------
main() {
  mkdir -p "$STATE_DIR"
  : >"$LOG_FILE"  # fresh log each run

  # Ensure deps BEFORE acquiring the lock (flock lives in util-linux)
  require_pkgs

  # Single-instance lock
  exec 9>"$LOCK_FILE"
  if ! flock -n 9; then
    log "Another instance is running. Exiting."
    exit 0
  fi

  trap 'log "ABORTED (line $LINENO)"; wake_lock_release' ERR
  trap 'wake_lock_release' EXIT

  wake_lock_acquire

  # Determine triggers
  local apk_triggered="no" json_triggered="no"
  if [ ! -f "$FIRST_RUN_FLAG" ]; then
    log "First run detected — running APK and JSON tasks."
    : >"$FIRST_RUN_FLAG"
    apk_triggered="yes"
    json_triggered="yes"
  else
    if [ "$(fetch_trigger "$TRIGGER_APK_URL" "$LAST_APK_TRIGGER")" = "changed" ]; then
      apk_triggered="yes"
      log "APK trigger detected."
    fi
    if [ "$(fetch_trigger "$TRIGGER_JSON_URL" "$LAST_JSON_TRIGGER")" = "changed" ]; then
      json_triggered="yes"
      log "JSON trigger detected."
    fi
  fi

  # Execute top features (no interference; each runs to completion)
  if [ "$apk_triggered" = "yes" ]; then
    task_apks
  else
    log "APK task: skipped (no trigger)."
  fi

  if [ "$json_triggered" = "yes" ]; then
    task_json
  else
    log "JSON task: skipped (no trigger)."
  fi

  # Post-run behavior
  # - If any top feature ran, do NOT run post script (so updates take precedence).
  # - If none ran and POST_SCRIPT_ENABLE=true, hand off according to mode.
  if [ "$apk_triggered" = "yes" ] || [ "$json_triggered" = "yes" ]; then
    log "Post script: disabled because a top feature ran."
    log "All tasks complete."
    # Normal exit; traps will release wake lock; lock released on fd close
    exit 0
  fi

  log "All tasks complete."

  if [ "$POST_SCRIPT_ENABLE" = "true" ]; then
    # Handoff: either exec (no interference) or supervise (stop on triggers)
    run_post_handoff
  fi

  # Nothing else to do; exit cleanly so any subsequent user scripts can run normally.
  # Traps will release wake lock; fd lock is released on exit.
  exit 0
}

main "$@"
