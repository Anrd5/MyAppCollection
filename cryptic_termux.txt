#!/data/data/com.termux/files/usr/bin/bash
set -Eeuo pipefail
IFS=$'\n\t'
umask 022

# =========================
# Config: edit if you need
# =========================
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

APK_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshClones.txt"

JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"
JSON_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshScript.txt"

DEST_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
DEST_JSON="${DEST_DIR}/Grow a Garden.json"

OTHER_LUA_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"
OTHER_LUA_PATH="/sdcard/download/reconnect.lua"

# Paths/state
STATE_DIR="$HOME/.config/auto-sync"
LOG_FILE="$STATE_DIR/auto.log"
PID_FILE="$STATE_DIR/reconnect.pid"
APK_CACHE="/sdcard/Download/ApkCache"
TMP_DIR="$STATE_DIR/tmp"

# Timing
POLL_SECONDS=20

# =========================
# Helpers
# =========================
mkdir -p "$STATE_DIR" "$TMP_DIR" "$APK_CACHE"

log() {
  printf '[%(%Y-%m-%d %H:%M:%S)T] %s\n' -1 "$*" | tee -a "$LOG_FILE" >&2
}

has_su() {
  command -v su >/dev/null 2>&1 && su -c 'id -u' >/dev/null 2>&1
}

ensure_storage() {
  if [ ! -d "/storage/emulated/0" ]; then
    log "Requesting storage permission (termux-setup-storage)..."
    termux-setup-storage || true
    sleep 2
  fi
}

retry_curl() {
  # retry_curl <output> <url>
  local out="$1" url="$2"
  curl -fsSL --retry 5 --retry-delay 2 --connect-timeout 10 -o "$out" "$url"
}

fetch_text_trigger() {
  # returns 0 or 1; defaults to 0 on error/noise
  local url="$1" val
  if ! val="$(curl -fsSL --retry 5 --retry-delay 2 --connect-timeout 10 "$url" 2>/dev/null | tr -cd '01' | head -c1)"; then
    echo "0"
    return
  fi
  [ -z "$val" ] && val="0"
  echo "$val"
}

read_state() {
  local f="$1" default="$2"
  if [ -f "$f" ]; then
    cat "$f"
  else
    echo "$default"
  fi
}

write_state() {
  local f="$1" val="$2"
  printf "%s" "$val" >"$f.tmp"
  mv -f "$f.tmp" "$f"
}

kill_reconnect_if_running() {
  if [ -f "$PID_FILE" ]; then
    local pid
    pid="$(cat "$PID_FILE" 2>/dev/null || echo "")"
    if [ -n "${pid}" ] && kill -0 "$pid" 2>/dev/null; then
      log "Stopping reconnect.lua (PID $pid)..."
      kill -TERM "$pid" 2>/dev/null || true
      # Wait up to 10s, then force
      for i in $(seq 1 10); do
        if kill -0 "$pid" 2>/dev/null; then
          sleep 1
        else
          break
        fi
      done
      if kill -0 "$pid" 2>/dev/null; then
        kill -KILL "$pid" 2>/dev/null || true
      fi
    fi
    rm -f "$PID_FILE"
  fi
}

install_apk() {
  local apk="$1"
  if has_su; then
    su -c "pm install -r --user 0 \"$apk\"" \
    || su -c "cmd package install -r \"$apk\""
  else
    pm install -r "$apk" \
    || cmd package install -r "$apk"
  fi
}

# =========================
# Tasks
# =========================
run_apk_task() {
  log "APK task: starting downloads..."
  mkdir -p "$APK_CACHE"
  local any_dl=0
  for url in "${APK_URLS[@]}"; do
    local name="${url##*/}"
    local out="$APK_CACHE/$name"
    log "Downloading $name"
    retry_curl "$out.tmp" "$url"
    mv -f "$out.tmp" "$out"
    any_dl=1
  done
  log "APK task: installing..."
  local fails=0
  for apk in "$APK_CACHE"/*.apk; do
    [ -f "$apk" ] || continue
    log "Installing $(basename "$apk")"
    if install_apk "$apk"; then
      log "Installed: $(basename "$apk")"
    else
      log "ERROR installing: $(basename "$apk")"
      fails=$((fails+1))
    fi
  done
  if [ "$fails" -gt 0 ]; then
    log "APK task finished with $fails install error(s)."
  else
    log "APK task: all installs succeeded."
  fi
}

run_json_task() {
  ensure_storage
  mkdir -p "$DEST_DIR"
  local tmp_json="$TMP_DIR/SpeedHubX.Config.json"
  log "JSON task: downloading config..."
  retry_curl "$tmp_json" "$JSON_URL"

  # Replace contents atomically
  local dest_tmp="${DEST_JSON}.tmp"
  cp -f "$tmp_json" "$dest_tmp"
  mv -f "$dest_tmp" "$DEST_JSON"
  sync || true
  log "JSON task: replaced contents of $(basename "$DEST_JSON")"
}

run_other_script() {
  ensure_storage
  log "OTHER: downloading reconnect.lua..."
  retry_curl "$OTHER_LUA_PATH.tmp" "$OTHER_LUA_URL"
  mv -f "$OTHER_LUA_PATH.tmp" "$OTHER_LUA_PATH"

  log "OTHER: starting reconnect.lua (managed; will stop if triggers fire)..."
  # Run in a managed background process so we can preempt if triggers fire.
  # This keeps APK/JSON tasks from interfering; they can stop this when needed.
  lua "$OTHER_LUA_PATH" &
  local pid=$!
  echo "$pid" >"$PID_FILE"
  wait "$pid" || true
  rm -f "$PID_FILE"
  log "OTHER: reconnect.lua finished."
}

# =========================
# Main loop
# =========================
main() {
  log "=== Auto Sync starting ==="
  log "State dir: $STATE_DIR"
  log "Log file:  $LOG_FILE"

  # Ensure tools
  command -v curl >/dev/null || { log "curl missing; installing..."; pkg install -y curl; }
  command -v lua  >/dev/null || { log "lua missing; installing...";  pkg install -y lua;  }

  # Initialize state
  local apk_state_file="$STATE_DIR/apk_trigger.last"
  local json_state_file="$STATE_DIR/json_trigger.last"
  local did_apk_since_other_file="$STATE_DIR/did_apk.flag"
  local did_json_since_other_file="$STATE_DIR/did_json.flag"

  write_state "$did_apk_since_other_file" "0"
  write_state "$did_json_since_other_file" "0"
  [ -f "$apk_state_file" ]  || write_state "$apk_state_file" "0"
  [ -f "$json_state_file" ] || write_state "$json_state_file" "0"

  while true; do
    # Read current triggers
    local apk_cur json_cur
    apk_cur="$(fetch_text_trigger "$APK_TRIGGER_URL" || echo 0)"
    json_cur="$(fetch_text_trigger "$JSON_TRIGGER_URL" || echo 0)"

    # Read last triggers
    local apk_last json_last
    apk_last="$(read_state "$apk_state_file" "0")"
    json_last="$(read_state "$json_state_file" "0")"

    # Detect rising edges: 0 -> 1
    local apk_rise="0" json_rise="0"
    if [ "$apk_last" = "0" ] && [ "$apk_cur" = "1" ]; then
      apk_rise="1"
    fi
    if [ "$json_last" = "0" ] && [ "$json_cur" = "1" ]; then
      json_rise="1"
    fi

    # Update stored states if changed
    if [ "$apk_cur" != "$apk_last" ]; then write_state "$apk_state_file" "$apk_cur"; fi
    if [ "$json_cur" != "$json_last" ]; then write_state "$json_state_file" "$json_cur"; fi

    # If any rising edge, preempt OTHER
    if [ "$apk_rise" = "1" ] || [ "$json_rise" = "1" ]; then
      kill_reconnect_if_running
    fi

    # Run tasks on rising edges
    if [ "$apk_rise" = "1" ]; then
      run_apk_task
      write_state "$did_apk_since_other_file" "1"
    fi

    if [ "$json_rise" = "1" ]; then
      run_json_task
      write_state "$did_json_since_other_file" "1"
    fi

    # When both tasks have run at least once since last OTHER, and both triggers are currently 0, run OTHER
    local did_apk did_json
    did_apk="$(read_state "$did_apk_since_other_file" "0")"
    did_json="$(read_state "$did_json_since_other_file" "0")"

    if [ "$did_apk" = "1" ] && [ "$did_json" = "1" ] && [ "$apk_cur" = "0" ] && [ "$json_cur" = "0" ]; then
      # Double-check no OTHER running
      if [ ! -f "$PID_FILE" ] || ! kill -0 "$(cat "$PID_FILE" 2>/dev/null || echo 0)" 2>/dev/null; then
        run_other_script
        # Reset cycle flags
        write_state "$did_apk_since_other_file" "0"
        write_state "$did_json_since_other_file" "0"
      fi
    fi

    sleep "$POLL_SECONDS"
  done
}

main "$@"
