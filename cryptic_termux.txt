#!/usr/bin/env bash
# cryptic_daemon.sh â€” watches triggers, installs APKs, updates config,
# and only launches the reconnect UI AFTER work finishes. While reconnect is
# running, we do not touch it unless a trigger requests work; then we stop it,
# do the work, and launch it again at the end.

set -u

# ----------------- Basic config -----------------
WORKDIR="${WORKDIR:-$HOME/cryptic_apks}"
POLL_INTERVAL="${POLL_INTERVAL:-30}"  # seconds

# Trigger files (expect '0' or '1')
TRIGGER_URL="${TRIGGER_URL:-https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshClones.txt}"
SCRIPT_TRIGGER_URL="${SCRIPT_TRIGGER_URL:-https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshScript.txt}"

# APK list
LINKS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# Config update
JSON_SOURCE_URL="${JSON_SOURCE_URL:-https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json}"
JSON_DEST="${JSON_DEST:-/storage/emulated/0/cryptic/Workspace/SpeedHubX/Grow a Garden.json}"

# Reconnect (explicit single-run: curl, then lua)
RECONNECT_URL="${RECONNECT_URL:-http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsTvDxmeexSCuVwX321098d1fgg}"
RECONNECT_LUA="${RECONNECT_LUA:-/sdcard/download/reconnect.lua}"
RECONNECT_PIDFILE="${RECONNECT_PIDFILE:-$WORKDIR/reconnect_ui.pid}"

# State files
STATE_FILE_CLONES="${WORKDIR}/.last_refresh_clones"
STATE_FILE_SCRIPT="${WORKDIR}/.last_refresh_script"

# ----------------- Setup -----------------
mkdir -p "$WORKDIR"

log() {
  printf '[%s] %s\n' "$(date '+%Y-%m-%dT%H:%M:%S%z')" "$*"
}

ensure_storage() {
  if [ ! -d "/sdcard" ] || [ ! -d "/sdcard/download" ]; then
    command -v termux-setup-storage >/dev/null 2>&1 && termux-setup-storage >/dev/null 2>&1 || true
    mkdir -p /sdcard/download 2>/dev/null || true
  fi
}

# Downloader for APKs/JSON: prefer curl, fallback wget
DL_TOOL=""
if command -v curl >/dev/null 2>&1; then
  DL_TOOL="curl"
elif command -v wget >/dev/null 2>&1; then
  DL_TOOL="wget"
else
  command -v pkg >/dev/null 2>&1 && pkg update -y >/dev/null 2>&1 || true
  command -v pkg >/dev/null 2>&1 && pkg install -y curl >/dev/null 2>&1 || true
  if command -v curl >/dev/null 2>&1; then
    DL_TOOL="curl"
  elif command -v wget >/dev/null 2>&1; then
    DL_TOOL="wget"
  else
    log "No curl/wget available. Install one and re-run."
    exit 1
  fi
fi
log "Downloader: $DL_TOOL"

download_file() {
  local url="$1" out="$2"
  if [ "$DL_TOOL" = "curl" ]; then
    curl -L -C - -o "$out" "$url"
  else
    wget -c -O "$out" "$url"
  fi
}

get_remote_flag() {
  local url="$1" content=""
  if [ "$DL_TOOL" = "curl" ]; then
    content="$(curl -fsSL "$url" 2>/dev/null || true)"
  else
    content="$(wget -qO- "$url" 2>/dev/null || true)"
  fi
  content="$(printf '%s' "$content" | tr -d ' \t\r\n' | cut -c1 || true)"
  case "$content" in
    0|1) printf '%s' "$content" ;;
    *) printf '' ;;
  esac
}

# ----------------- Root + installs -----------------
ROOT_CMD=""
if command -v tsu >/dev/null 2>&1; then
  ROOT_CMD="tsu --"
elif command -v su >/dev/null 2>&1; then
  ROOT_CMD="su -c"
else
  log "No root found (tsu/su). Silent pm installs require root."
  log "Install tsu (pkg install tsu) or ensure su is available."
fi

install_apk_root() {
  local apk="$1"
  if [ -z "$ROOT_CMD" ]; then
    log "Skipping install (no root): $apk"
    return 1
  fi
  if command -v tsu >/dev/null 2>&1; then
    tsu pm install -r -g "$apk"
  else
    su -c "pm install -r -g '$apk'"
  fi
}

do_downloads_and_installs() {
  log "Starting APK batch ..."
  for url in "${LINKS[@]}"; do
    local fname="${url##*/}"
    log "Downloading: $fname"
    download_file "$url" "$WORKDIR/$fname" || { log "Download failed: $fname"; continue; }
    if [ ! -s "$WORKDIR/$fname" ]; then
      log "Empty file, skipping: $fname"
      continue
    fi
    log "Installing: $fname"
    install_apk_root "$WORKDIR/$fname" && log "Installed: $fname" || log "Install failed: $fname"
  done
  log "APK batch complete."
}

update_json_from_remote() {
  log "Updating JSON -> $JSON_DEST"
  local tmp="$WORKDIR/SpeedHubX.Config.json.tmp"
  download_file "$JSON_SOURCE_URL" "$tmp" || { log "JSON download failed"; return 1; }
  if [ ! -s "$tmp" ]; then
    log "JSON is empty. Aborting."
    return 1
  fi
  local dest_dir; dest_dir="$(dirname "$JSON_DEST")"
  if [ -n "$ROOT_CMD" ]; then
    if command -v tsu >/dev/null 2>&1; then
      tsu -- sh -c "mkdir -p '$dest_dir' && cp -f '$tmp' '$JSON_DEST'"
    else
      su -c "mkdir -p '$dest_dir' && cp -f '$tmp' '$JSON_DEST'"
    fi
  else
    mkdir -p "$dest_dir" 2>/dev/null || true
    cp -f "$tmp" "$JSON_DEST" 2>/dev/null || { log "Copy failed (no root?)"; return 1; }
  fi
  log "JSON updated."
  rm -f "$tmp" 2>/dev/null || true
}

# ----------------- Reconnect UI management (single-run, no interference) -----------------
ensure_lua() {
  if command -v lua >/dev/null 2>&1; then return 0; fi
  log "Lua not found. Attempting to install..."
  command -v pkg >/dev/null 2>&1 && pkg update -y >/dev/null 2>&1 || true
  command -v pkg >/dev/null 2>&1 && pkg install -y lua >/dev/null 2>&1 || true
  command -v lua >/dev/null 2>&1 || { log "Lua still missing. Reconnect may not start."; return 1; }
}

reconnect_running() {
  [ -f "$RECONNECT_PIDFILE" ] || return 1
  local pid; pid="$(cat "$RECONNECT_PIDFILE" 2>/dev/null || true)"
  [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null
}

start_reconnect_ui_once() {
  # Execute exactly:
  #   curl -L -o /sdcard/download/reconnect.lua <RECONNECT_URL>
  #   lua /sdcard/download/reconnect.lua
  ensure_storage
  ensure_lua || true

  if ! command -v curl >/dev/null 2>&1; then
    log "curl not found; attempting to install..."
    command -v pkg >/dev/null 2>&1 && pkg update -y >/dev/null 2>&1 || true
    command -v pkg >/dev/null 2>&1 && pkg install -y curl >/dev/null 2>&1 || true
  fi
  if ! command -v curl >/dev/null 2>&1; then
    log "Cannot start reconnect: curl is unavailable."
    return 1
  fi

  # Fetch latest reconnect script
  log "Fetching reconnect.lua ..."
  if ! curl -L -o "$RECONNECT_LUA" "$RECONNECT_URL"; then
    log "Failed to download reconnect.lua"
    return 1
  fi
  if [ ! -s "$RECONNECT_LUA" ]; then
    log "Downloaded reconnect.lua is empty."
    return 1
  fi

  # Launch UI script in background; do NOT loop or auto-restart.
  # Detach stdio to avoid interfering with its interface.
  log "Launching reconnect UI ..."
  nohup lua "$RECONNECT_LUA" >/dev/null 2>&1 &
  echo $! > "$RECONNECT_PIDFILE"
  log "Reconnect UI started (PID $(cat "$RECONNECT_PIDFILE"))."
}

stop_reconnect_ui() {
  [ -f "$RECONNECT_PIDFILE" ] || return 0
  local pid; pid="$(cat "$RECONNECT_PIDFILE" 2>/dev/null || true)"
  if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
    log "Stopping reconnect UI (PID $pid) ..."
    kill "$pid" 2>/dev/null || true
    # Give it a moment, then force if needed
    sleep 1
    kill -0 "$pid" 2>/dev/null && kill -9 "$pid" 2>/dev/null || true
  fi
  rm -f "$RECONNECT_PIDFILE" 2>/dev/null || true
}

trap 'stop_reconnect_ui; exit 0' INT TERM

# ----------------- Main loop -----------------
ensure_storage

last_clones=""
last_script=""
[ -f "$STATE_FILE_CLONES" ] && last_clones="$(cat "$STATE_FILE_CLONES" 2>/dev/null || true)"
[ -f "$STATE_FILE_SCRIPT" ] && last_script="$(cat "$STATE_FILE_SCRIPT" 2>/dev/null || true)"

log "Daemon started. Poll interval: ${POLL_INTERVAL}s"
log "Triggers: clones=$TRIGGER_URL (last='$last_clones'), script=$SCRIPT_TRIGGER_URL (last='$last_script')"
log "Reconnect UI is OFF by default and will only start after work completes."

while true; do
  remote_clones="$(get_remote_flag "$TRIGGER_URL")"
  remote_script="$(get_remote_flag "$SCRIPT_TRIGGER_URL")"

  did_work="0"
  need_stop_reconnect="0"

  # Detect changes
  clones_changed="0"; script_changed="0"
  if [ -z "$remote_clones" ]; then
    log "WARN: could not read RefreshClones.txt"
  elif [ "$remote_clones" != "$last_clones" ]; then
    clones_changed="1"
  fi
  if [ -z "$remote_script" ]; then
    log "WARN: could not read RefreshScript.txt"
  elif [ "$remote_script" != "$last_script" ]; then
    script_changed="1"
  fi

  # If any trigger changed to '1', we must stop reconnect BEFORE doing work
  if { [ "$clones_changed" = "1" ] && [ "$remote_clones" = "1" ]; } || \
     { [ "$script_changed" = "1" ] && [ "$remote_script" = "1" ]; }; then
    need_stop_reconnect="1"
  fi

  if [ "$need_stop_reconnect" = "1" ] && reconnect_running; then
    stop_reconnect_ui
  fi

  # Handle clones
  if [ "$clones_changed" = "1" ]; then
    log "RefreshClones changed: '$last_clones' -> '$remote_clones'"
    if [ "$remote_clones" = "1" ]; then
      do_downloads_and_installs && did_work="1"
    fi
    printf '%s' "$remote_clones" > "$STATE_FILE_CLONES"
    last_clones="$remote_clones"
  fi

  # Handle script
  if [ "$script_changed" = "1" ]; then
    log "RefreshScript changed: '$last_script' -> '$remote_script'"
    if [ "$remote_script" = "1" ]; then
      update_json_from_remote && did_work="1"
    fi
    printf '%s' "$remote_script" > "$STATE_FILE_SCRIPT"
    last_script="$remote_script"
  fi

  # At the end, ONLY if we actually did work, (re)launch reconnect UI once.
  if [ "$did_work" = "1" ]; then
    start_reconnect_ui_once || true
  fi

  sleep "$POLL_INTERVAL"
done
