#!/data/data/com.termux/files/usr/bin/bash
# cryptic-auto.sh â€” Termux automation daemon for APKs, JSON, and "Other" script.
# Requires: tsu (root), curl, jq, flock, pm, lua (for running reconnect.lua)
# Behavior:
# - Runs under root (tsu). Re-execs itself with tsu if needed.
# - Polls GitHub trigger files so APK install + JSON replace run exactly once per workflow run.
# - First-time run: performs APK + JSON tasks unconditionally, then records remote run-ids.
# - "Other" script runs only if neither APK nor JSON task ran in the current cycle.
# - "Other" script is foreground only (never backgrounded). Forces non-zero code when it finishes.
# - APKs stored in $HOME/apks and deleted after install.
# - JSON written to /storage/emulated/0/Cryptic/Workspace/SpeedHubX/Grow a Garden.json
# - Designed for Android 10, VMOS Cloud, rooted via Magisk/tsu.

set -Eeuo pipefail

#----- Root re-exec via tsu ----------------------------------------------------
if [ "$(id -u)" -ne 0 ]; then
  if command -v tsu >/dev/null 2>&1; then
    exec tsu -c "$0" "$@"
  else
    echo "[FATAL] tsu not found. Install tsu and re-run." >&2
    exit 97
  fi
fi

#----- Config ------------------------------------------------------------------
SCRIPT_NAME="cryptic-auto.sh"
LOCK_DIR="${HOME}/.cryptic_locks"
STATE_DIR="${HOME}/.cryptic_state"
LOG_DIR="${HOME}/.cryptic_logs"
APK_DIR="${HOME}/apks"
JSON_TARGET_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
JSON_TARGET_FILE="${JSON_TARGET_DIR}/Grow a Garden.json"
RECONNECT_DL_DIR="/sdcard/download"
RECONNECT_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"
RECONNECT_LOCAL="${RECONNECT_DL_DIR}/reconnect.lua"
SLEEP_SECS=300   # Poll interval: 5 minutes. Adjust if desired.

# Your repo/branch where triggers will live (as created by the workflows below)
REPO_OWNER="Anrd5"
REPO_NAME="MyAppCollection"
REPO_BRANCH="main"

# Trigger file raw URLs created by workflows (see YAML below)
TRIGGER_APK_RAW="https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${REPO_BRANCH}/.triggers/apk/latest.json"
TRIGGER_JSON_RAW="https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${REPO_BRANCH}/.triggers/json/latest.json"

# State files to remember the last handled workflow run
STATE_APK_ID="${STATE_DIR}/apk_last_run_id"
STATE_JSON_ID="${STATE_DIR}/json_last_run_id"
STATE_FIRST_RUN="${STATE_DIR}/first_run_done"

# APK sources (stored under $HOME/apks)
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# JSON source
JSON_SOURCE_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"

#----- Utilities ---------------------------------------------------------------
mkdir -p "${LOCK_DIR}" "${STATE_DIR}" "${LOG_DIR}" "${APK_DIR}" "${JSON_TARGET_DIR}" "${RECONNECT_DL_DIR}"

log() {
  local ts
  ts="$(date '+%Y-%m-%d %H:%M:%S')"
  echo "[$ts] $*"
  echo "[$ts] $*" >> "${LOG_DIR}/${SCRIPT_NAME}.log"
}

# Safe curl wrapper
fetch() {
  # $1=url  $2=out_path
  local url="$1" out="$2"
  curl -fL --retry 5 --retry-all-errors --connect-timeout 20 --max-time 300 -o "$out" "$url"
}

# Parse run_id from trigger JSON safely
get_run_id() {
  # $1=trigger_raw_url
  local url="$1"
  local tmp
  tmp="$(mktemp)"
  if ! fetch "$url" "$tmp"; then
    rm -f "$tmp"
    echo ""
    return 1
  fi
  local rid
  rid="$(jq -r '(.run_id // .id // .runId // empty)' "$tmp" 2>/dev/null || true)"
  rm -f "$tmp"
  echo "$rid"
  return 0
}

# Gate to ensure we can write to shared storage
ensure_storage_access() {
  # Best-effort: if target not writable, attempt termux-setup-storage once.
  if [ ! -w "/storage/emulated/0" ] || [ ! -w "$(dirname "${JSON_TARGET_FILE}")" ]; then
    if command -v termux-setup-storage >/dev/null 2>&1; then
      termux-setup-storage || true
    fi
    mkdir -p "${JSON_TARGET_DIR}" || true
  fi
}

#----- Tasks -------------------------------------------------------------------

download_and_install_apks() {
  local lock="${LOCK_DIR}/apk.lock"
  exec 9>"$lock"
  flock -n 9 || { log "APK task already running; skipping."; return 0; }

  log "APK: Starting download and install for ${#APK_URLS[@]} APK(s)."
  local any_installed=0

  for url in "${APK_URLS[@]}"; do
    local fname
    fname="${APK_DIR}/$(basename "$url")"
    log "APK: Fetching $(basename "$url")"
    if fetch "$url" "$fname"; then
      # Basic sanity: ensure it's an APK file
      if file "$fname" | grep -qi "Android package"; then
        log "APK: Installing $(basename "$fname")"
        if pm install -r "$fname"; then
          any_installed=1
          log "APK: Installed $(basename "$fname"). Deleting local APK."
          rm -f "$fname" || true
        else
          log "APK: pm install failed for $(basename "$fname"). Keeping file for inspection."
        fi
      else
        log "APK: $(basename "$fname") does not look like an APK. Removing."
        rm -f "$fname" || true
      fi
    else
      log "APK: Download failed for $url"
    fi
  done

  if [ "$any_installed" -eq 1 ]; then
    # Double-sweep in case some APKs remain
    find "$APK_DIR" -type f -name "*.apk" -delete 2>/dev/null || true
  fi

  log "APK: Completed."
}

download_and_replace_json() {
  local lock="${LOCK_DIR}/json.lock"
  exec 8>"$lock"
  flock -n 8 || { log "JSON task already running; skipping."; return 0; }

  ensure_storage_access

  local tmp
  tmp="$(mktemp)"
  log "JSON: Fetching ${JSON_SOURCE_URL}"
  if ! fetch "${JSON_SOURCE_URL}" "$tmp"; then
    log "JSON: Download failed."
    rm -f "$tmp"
    return 0
  fi

  # Validate JSON minimally with jq if available
  if command -v jq >/dev/null 2>&1; then
    if ! jq empty "$tmp" 2>/dev/null; then
      log "JSON: Downloaded file is not valid JSON. Aborting replace."
      rm -f "$tmp"
      return 0
    fi
  fi

  # Atomic replace
  local dst="${JSON_TARGET_FILE}"
  local bak="${dst}.bak.$(date +%s)"
  if [ -f "$dst" ]; then
    cp -f "$dst" "$bak" || true
  fi

  if mv -f "$tmp" "$dst"; then
    log "JSON: Replaced contents of $(basename "$dst")."
  else
    log "JSON: Failed to move new JSON into place."
    rm -f "$tmp"
  fi
}

run_other_script() {
  local lock="${LOCK_DIR}/other.lock"
  exec 7>"$lock"
  flock -n 7 || { log "OTHER: Already running; skipping."; return 0; }

  # Ensure destination dir exists (user explicitly uses /sdcard/download)
  mkdir -p "${RECONNECT_DL_DIR}" || true

  log "OTHER: Downloading reconnect.lua"
  if ! fetch "${RECONNECT_URL}" "${RECONNECT_LOCAL}"; then
    log "OTHER: Failed to download reconnect.lua"
    return 0
  fi

  # Run in foreground, never background. Capture exit code.
  log "OTHER: Running reconnect.lua in foreground (no background)."
  lua "${RECONNECT_LOCAL}"
  local rc=$?

  # Enforce "No zero exit codes when reconnect.lua is executed."
  # If script returns 0, convert it to a non-zero code to satisfy the requirement.
  if [ "$rc" -eq 0 ]; then
    log "OTHER: reconnect.lua reported 0; forcing non-zero exit code per requirement."
    rc=99
  fi

  # Propagate non-zero to the caller function return without terminating the daemon.
  # We also log it for external observers.
  log "OTHER: reconnect.lua finished with exit code ${rc}."
  return "$rc"
}

#----- First-run logic ---------------------------------------------------------
first_run_init() {
  if [ ! -f "${STATE_FIRST_RUN}" ]; then
    log "FIRST-RUN: Performing APK + JSON tasks once."
    download_and_install_apks
    download_and_replace_json

    # Record current upstream run ids if available to avoid re-running immediately
    local cur_apk="$(get_run_id "${TRIGGER_APK_RAW}" || true)"
    local cur_json="$(get_run_id "${TRIGGER_JSON_RAW}" || true)"
    : > "${STATE_FIRST_RUN}"
    echo "${cur_apk:-none}" > "${STATE_APK_ID}"
    echo "${cur_json:-none}" > "${STATE_JSON_ID}"
    log "FIRST-RUN: Initialized state (apk_run_id=${cur_apk:-none}, json_run_id=${cur_json:-none})."
  fi
}

#----- Main loop ---------------------------------------------------------------
main_loop() {
  log "Daemon: Starting ${SCRIPT_NAME}."
  first_run_init

  while :; do
    local did_apk=0
    local did_json=0

    # Check APK trigger
    local last_apk="none"
    [ -f "${STATE_APK_ID}" ] && last_apk="$(cat "${STATE_APK_ID}" || echo none)"
    local cur_apk="$(get_run_id "${TRIGGER_APK_RAW}" || echo "")"
    if [ -n "$cur_apk" ] && [ "$cur_apk" != "$last_apk" ]; then
      log "Trigger(APK): New run detected (old=${last_apk} new=${cur_apk})."
      download_and_install_apks
      echo "$cur_apk" > "${STATE_APK_ID}"
      did_apk=1
    else
      log "Trigger(APK): No new run (current=${cur_apk:-unavailable})."
    fi

    # Check JSON trigger
    local last_json="none"
    [ -f "${STATE_JSON_ID}" ] && last_json="$(cat "${STATE_JSON_ID}" || echo none)"
    local cur_json="$(get_run_id "${TRIGGER_JSON_RAW}" || echo "")"
    if [ -n "$cur_json" ] && [ "$cur_json" != "$last_json" ]; then
      log "Trigger(JSON): New run detected (old=${last_json} new=${cur_json})."
      download_and_replace_json
      echo "$cur_json" > "${STATE_JSON_ID}"
      did_json=1
    else
      log "Trigger(JSON): No new run (current=${cur_json:-unavailable})."
    fi

    # OTHER runs only when the above features won't interfere:
    # - If either APK or JSON ran this cycle, do NOT run OTHER this cycle.
    if [ "$did_apk" -eq 0 ] && [ "$did_json" -eq 0 ]; then
      log "Daemon: Running OTHER (no APK/JSON ran this cycle)."
      # We deliberately ignore the return for daemon continuity, but we do not convert daemon exit code.
      if ! run_other_script; then
        # run_other_script returns non-zero by design; log it and continue.
        :
      fi
    else
      log "Daemon: Skipping OTHER (APK/JSON were active this cycle)."
    fi

    log "Daemon: Sleeping ${SLEEP_SECS}s."
    sleep "${SLEEP_SECS}"
  done
}

main_loop
