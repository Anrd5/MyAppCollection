#!/data/data/com.termux/files/usr/bin/bash
# Cryptic clones watcher/installer for Termux
# - Watches a GitHub Release asset "RefreshClones.txt" for a 0→1 flip
# - On a flip, downloads Cryptic0.apk … Cryptic7.apk if present and installs
# - Root: installs silently via pm; No root: opens installer UI per APK
# - Can run as a daemon. Writes logs/PID/state into WORKDIR.
#
# Save this file in your repo at:
#   https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/cryptic_termux.txt
# Then run via the one-liner in Termux.

set -Eeuo pipefail

# ---------- Defaults (override via env or flags) ----------
REPO_OWNER="${REPO_OWNER:-Anrd5}"
REPO_NAME="${REPO_NAME:-MyAppCollection}"
RELEASE_TAG="${RELEASE_TAG:-V1.0}"
SELF_URL="${SELF_URL:-https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/refs/heads/main/cryptic_termux.txt}"

WORKDIR="${WORKDIR:-$HOME/cryptic_apks}"
LOGFILE="${LOGFILE:-$HOME/cryptic_daemon.log}"
PIDFILE="${PIDFILE:-$WORKDIR/cryptic_daemon.pid}"
STATEFILE="${STATEFILE:-$WORKDIR/last_trigger.state}"

# Poll interval in seconds
POLL_INTERVAL="${POLL_INTERVAL:-30}"

# Keep downloaded APKs (1=yes, 0=no)
KEEP_APKS="${KEEP_APKS:-0}"

# Comma- or space-separated list of clone indices to process (default 0..7)
CLONES="${CLONES:-0 1 2 3 4 5 6 7}"

# ---------- Derived ----------
DOWNLOAD_BASE="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases/download/${RELEASE_TAG}"
TRIGGER_URL="${TRIGGER_URL:-${DOWNLOAD_BASE}/RefreshClones.txt}"

# ---------- Helpers ----------
ts() { date +"%Y-%m-%d %H:%M:%S"; }
log() { printf "[%s] %s\n" "$(ts)" "$*" | tee -a "$LOGFILE"; }
die() { log "ERROR: $*"; exit 1; }
have() { command -v "$1" >/dev/null 2>&1; }

ensure_dirs() {
  mkdir -p "$WORKDIR"
  touch "$LOGFILE"
}

write_pid() {
  echo "$$" >"$PIDFILE"
}

clean_pid() {
  [ -f "$PIDFILE" ] && rm -f "$PIDFILE" || true
}

trap 'clean_pid' EXIT

root_runner=""
detect_root() {
  if have tsu; then
    root_runner="tsu -c"
  elif have su; then
    root_runner="su -c"
  else
    root_runner=""
  fi
}

install_apk() {
  local apk="$1"
  if [ -n "$root_runner" ]; then
    log "Installing (silent, root): $(basename "$apk")"
    # Allow downgrade (-d) and replace existing (-r)
    if $root_runner "pm install -r -d \"$apk\""; then
      log "Installed: $(basename "$apk")"
      return 0
    else
      log "pm install failed for $(basename "$apk")."
      return 1
    fi
  else
    # Fallback: prompt install via UI
    log "No root. Prompting installer UI for: $(basename "$apk")"
    if have termux-open; then
      termux-open -a android.intent.action.VIEW -t application/vnd.android.package-archive "$apk" || true
    else
      am start --grant-read-uri-permission -a android.intent.action.VIEW -d "file://$apk" -t application/vnd.android.package-archive >/dev/null 2>&1 || true
    fi
    # We can't know if user completed install; proceed to next.
    return 0
  fi
}

download_file() {
  local url="$1" out="$2"
  rm -f "$out.partial" 2>/dev/null || true
  log "Downloading: $url"
  if curl -fsSL --connect-timeout 10 --retry 3 --retry-delay 2 -o "$out.partial" "$url"; then
    mv -f "$out.partial" "$out"
    [ -s "$out" ] || { log "Downloaded file is empty: $out"; return 1; }
    return 0
  else
    log "Download failed: $url"
    rm -f "$out.partial" 2>/dev/null || true
    return 1
  fi
}

get_trigger_value() {
  local tmp="$WORKDIR/RefreshClones.txt"
  if download_file "$TRIGGER_URL" "$tmp"; then
    # Trim whitespace and non-digits
    tr -cd '0-9' <"$tmp" | head -c 1
  else
    echo "0"
  fi
}

should_fire() {
  local last="${1:-}"
  local now="${2:-}"
  # Edge-trigger only: fire when last==0 and now==1
  [ "$last" = "0" ] && [ "$now" = "1" ]
}

process_once() {
  detect_root
  local clones_list=()
  # Normalize CLONES to space-separated list
  IFS=', ' read -r -a clones_list <<<"$CLONES"

  local apk
  local to_cleanup=()
  local any_success=0

  for idx in "${clones_list[@]}"; do
    [[ "$idx" =~ ^[0-7]$ ]] || { log "Skipping invalid clone index: $idx"; continue; }
    local name="Cryptic${idx}.apk"
    local url="${DOWNLOAD_BASE}/${name}"
    local out="${WORKDIR}/${name}"

    if download_file "$url" "$out"; then
      install_apk "$out" && any_success=1
      if [ "${KEEP_APKS}" != "1" ]; then
        to_cleanup+=("$out")
      fi
    else
      log "Asset not available or failed: $name (skipped)"
    fi
  done

  # Cleanup if desired
  if [ "${KEEP_APKS}" != "1" ] && [ "${#to_cleanup[@]}" -gt 0 ]; then
    for f in "${to_cleanup[@]}"; do
      [ -f "$f" ] && rm -f "$f" || true
    done
    log "Cleaned up downloaded APKs."
  fi

  if [ "$any_success" -eq 1 ]; then
    log "Cycle complete."
  else
    log "No APKs were installed this cycle."
  fi
}

loop() {
  ensure_dirs
  write_pid
  log "==== Cryptic watcher started (repo=${REPO_OWNER}/${REPO_NAME}, tag=${RELEASE_TAG}) ===="
  log "Workdir: $WORKDIR | Log: $LOGFILE | PID: $PIDFILE | Poll: ${POLL_INTERVAL}s"
  log "Watching trigger: $TRIGGER_URL"
  : >"$STATEFILE" || true

  local last="init"
  if [ -f "$STATEFILE" ]; then
    last="$(cat "$STATEFILE" || echo "init")"
  fi

  while true; do
    local now
    now="$(get_trigger_value || echo 0)"
    [ "$last" = "init" ] && { echo "$now" >"$STATEFILE"; last="$now"; log "Initialized trigger state to: $now"; }

    if should_fire "$last" "$now"; then
      log "Trigger edge detected (0 → 1). Starting install cycle."
      process_once
      # Persist '1' so it won't fire again until reset to 0
      echo "1" >"$STATEFILE"
      last="1"
      log "Waiting for trigger to reset to 0..."
    else
      # Update last when it changes
      if [ "$now" != "$last" ]; then
        echo "$now" >"$STATEFILE"
        last="$now"
        log "Trigger state changed to: $now"
      fi
    fi

    sleep "$POLL_INTERVAL"
  done
}

usage() {
  cat <<EOF
Usage: bash cryptic_termux.txt [--daemonize] [--loop] [--pidfile PATH] [--logfile PATH]

Flags:
  --daemonize          Install/refresh a local copy of this script and start it as a background daemon.
  --loop               Run the watcher loop in the foreground (used by --daemonize).
  --test               Process only Cryptic0 once and exit.

Env vars:
  REPO_OWNER, REPO_NAME, RELEASE_TAG
  WORKDIR, LOGFILE, PIDFILE, STATEFILE
  POLL_INTERVAL (default 30)
  KEEP_APKS=1 to keep APKs after install
  CLONES="0 1 2 3 4 5 6 7" to select specific clones
  SELF_URL (raw URL to this script)
EOF
}

# ---------- Args ----------
DAEMONIZE=0
RUN_LOOP=0
TEST_MODE=0

while [ "${1-}" ]; do
  case "$1" in
    --daemonize) DAEMONIZE=1 ;;
    --loop) RUN_LOOP=1 ;;
    --test) TEST_MODE=1; CLONES="0" ;;
    --pidfile) shift; PIDFILE="$1" ;;
    --logfile) shift; LOGFILE="$1" ;;
    -h|--help) usage; exit 0 ;;
    *) echo "Unknown option: $1"; usage; exit 1 ;;
  esac
  shift || true
done

ensure_dirs

if [ "$DAEMONIZE" -eq 1 ]; then
  # Write/update local copy and launch it detached, so future updates come from the repo.
  local_copy="$WORKDIR/cryptic_termux.sh"
  log "Fetching latest script to $local_copy"
  download_file "$SELF_URL" "$local_copy" || die "Unable to fetch SELF_URL: $SELF_URL"
  chmod +x "$local_copy"
  # Prevent double-start
  if [ -f "$PIDFILE" ] && ps -p "$(cat "$PIDFILE" 2>/dev/null || echo 0)" >/dev/null 2>&1; then
    log "Daemon already running (PID $(cat "$PIDFILE"))."
    exit 0
  fi
  log "Starting daemon in background..."
  # Pass through key env vars
  nohup env \
    REPO_OWNER="$REPO_OWNER" REPO_NAME="$REPO_NAME" RELEASE_TAG="$RELEASE_TAG" \
    WORKDIR="$WORKDIR" LOGFILE="$LOGFILE" PIDFILE="$PIDFILE" STATEFILE="$STATEFILE" \
    POLL_INTERVAL="$POLL_INTERVAL" KEEP_APKS="$KEEP_APKS" CLONES="$CLONES" SELF_URL="$SELF_URL" \
    bash "$local_copy" --loop >>"$LOGFILE" 2>&1 &
  disown || true
  log "Daemon started."
  exit 0
fi

if [ "$RUN_LOOP" -eq 1 ]; then
  loop
  exit 0
fi

if [ "$TEST_MODE" -eq 1 ]; then
  process_once
  exit 0
fi

# Default: run one poll-and-install cycle if needed right now (edge-triggered)
# Initialize last to 0 so if remote is 1, this counts as a single fire and then sets last=1.
echo "0" >"$STATEFILE"
last="0"
now="$(get_trigger_value || echo 0)"
if should_fire "$last" "$now"; then
  log "One-shot: trigger is 1 and last was 0 → installing once."
  process_once
  echo "1" >"$STATEFILE"
else
  log "One-shot: no install. Trigger=$now (needs 0→1 flip)."
fi
