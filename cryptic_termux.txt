#!/data/data/com.termux/files/usr/bin/bash
# Termux Orchestrator: APK + JSON automation with trigger-aware "Other" script
# Android 10 / VMOS / Magisk root supported
# Continuous run + Termux:Boot hook (if installed)

set -u

# ----------------------------- Config -----------------------------
# APK sources
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# JSON source and destination
JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"
DEST_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
DEST_FILE="$DEST_DIR/Grow a Garden.json"

# “Other” script
OTHER_LUA_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"
OTHER_LUA_PATH="/sdcard/download/reconnect.lua"
OTHER_LUA_CMD="lua"   # fallback to lua53/luajit if 'lua' missing (handled below)

# Repo triggers (raw)
# Create these files via GitHub Actions workflows below
TRIGGER_APK_RAW="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/.triggers/apk.trigger"
TRIGGER_JSON_RAW="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/.triggers/json.trigger"

# Polling interval (seconds)
POLL_INTERVAL=120

# ----------------------------- Paths ------------------------------
PREFIX="${PREFIX:-/data/data/com.termux/files/usr}"
APKS_DIR="$HOME/apks"
STATE_DIR="$HOME/.termux-automation"
LOG_DIR="$STATE_DIR/logs"
STATE_FILE="$STATE_DIR/state.json"
LOCK_DIR="$STATE_DIR/lock"

# ----------------------------- Helpers ----------------------------
ts() { date +"%Y-%m-%d %H:%M:%S"; }
log() { echo "[$(ts)] $*" | tee -a "$LOG_DIR/main.log"; }
die() { log "ERROR: $*"; exit 1; }

json_get() {
  # json_get <key> -> value or empty
  jq -r ".$1 // empty" "$STATE_FILE" 2>/dev/null || true
}

json_set() {
  # json_set <key> <value-as-json>
  local k="$1"; local v="$2"
  if [ ! -f "$STATE_FILE" ]; then
    printf '{ }' > "$STATE_FILE"
  fi
  tmp="$(mktemp)"
  jq ".$k = $v" "$STATE_FILE" > "$tmp" && mv "$tmp" "$STATE_FILE"
}

ensure_dirs() {
  mkdir -p "$APKS_DIR" "$STATE_DIR" "$LOG_DIR"
}

ensure_lock() {
  if mkdir "$LOCK_DIR" 2>/dev/null; then
    trap 'rmdir "$LOCK_DIR" 2>/dev/null || true' EXIT
  else
    log "Another instance is running. Exiting."
    exit 0
  fi
}

ensure_deps() {
  # Minimal footprint but reliable
  pkg update -y >/dev/null 2>&1 || true
  pkg install -y curl jq coreutils grep sed wget >/dev/null 2>&1 || die "Package install failed"

  # Lua for 'Other' script
  if ! command -v lua >/dev/null 2>&1; then
    pkg install -y lua >/dev/null 2>&1 || true
  fi
  if ! command -v lua >/dev/null 2>&1; then
    pkg install -y lua53 >/dev/null 2>&1 || true
    if command -v lua53 >/dev/null 2>&1; then
      OTHER_LUA_CMD="lua53"
    fi
  fi
  if ! command -v "$OTHER_LUA_CMD" >/dev/null 2>&1; then
    pkg install -y luajit >/dev/null 2>&1 || true
    if command -v luajit >/dev/null 2>&1; then
      OTHER_LUA_CMD="luajit"
    fi
  fi

  # Storage access
  if [ ! -d "/sdcard" ]; then
    yes | termux-setup-storage >/dev/null 2>&1 || true
    sleep 2
  fi
}

setup_boot_hook() {
  # If Termux:Boot is installed, create a boot entry that starts this orchestrator
  local BOOT_DIR="$HOME/.termux/boot"
  if [ -d "$BOOT_DIR" ]; then
    mkdir -p "$BOOT_DIR"
    local BOOT_FILE="$BOOT_DIR/99-orchestrator.sh"
    cat > "$BOOT_FILE" <<'EOF'
#!/data/data/com.termux/files/usr/bin/bash
# Start orchestrator at boot (non-background; logs to file)
SCRIPT="$HOME/termux_orchestrator.sh"
LOG="$HOME/.termux-automation/logs/boot.log"
if [ -x "$SCRIPT" ]; then
  echo "[$(date)] Boot starting orchestrator" >> "$LOG"
  exec "$SCRIPT" >> "$LOG" 2>&1
fi
EOF
    chmod +x "$BOOT_FILE"
    log "Termux:Boot hook created at $BOOT_FILE"
  else
    log "Termux:Boot not detected. Skipping boot hook (safe to ignore)."
  fi
}

# ---------------------------- Installers --------------------------
have_root() { command -v su >/dev/null 2>&1; }

pm_install() {
  # pm_install <apk_path>
  local apk="$1"
  if have_root; then
    su -c "pm install -r --user 0 \"$apk\"" </dev/null
  else
    # Non-root fallback (may fail if device policy restricts)
    pm install -r "$apk"
  fi
}

install_all_apks() {
  log "APK: Downloading to $APKS_DIR (avoiding /sdcard/Download)"
  local ok=0 fail=0
  for url in "${APK_URLS[@]}"; do
    local name="$(basename "$url")"
    local dst="$APKS_DIR/$name"
    log "APK: Fetch $name"
    if curl -fL --connect-timeout 20 --retry 3 --retry-delay 2 -o "$dst" "$url"; then
      if [ -s "$dst" ]; then
        log "APK: Installing $name"
        if pm_install "$dst" 2>&1 | tee -a "$LOG_DIR/pm.log" | grep -qi "Success"; then
          log "APK: Installed $name; deleting file"
          rm -f "$dst"
          ok=$((ok+1))
        else
          log "APK: Install failed for $name; keeping file in $APKS_DIR/failed"
          mkdir -p "$APKS_DIR/failed"
          mv -f "$dst" "$APKS_DIR/failed/$name" 2>/dev/null || true
          fail=$((fail+1))
        fi
      else
        log "APK: Empty download for $name"
        rm -f "$dst"
        fail=$((fail+1))
      fi
    else
      log "APK: Download failed for $name"
      rm -f "$dst"
      fail=$((fail+1))
    fi
    sleep 1
  done
  log "APK: Completed installs. OK=$ok FAIL=$fail"
  return 0
}

update_json_file() {
  mkdir -p "$DEST_DIR" || true
  local tmp="$(mktemp)"
  log "JSON: Downloading config"
  if curl -fL --connect-timeout 20 --retry 3 --retry-delay 2 -o "$tmp" "$JSON_URL"; then
    if [ -s "$tmp" ]; then
      log "JSON: Replacing contents of $DEST_FILE"
      # Ensure file exists then replace content atomically
      touch "$DEST_FILE"
      cat "$tmp" > "$DEST_FILE"
      rm -f "$tmp"
      log "JSON: Replace complete"
      return 0
    fi
  fi
  rm -f "$tmp"
  log "JSON: Download or replace failed"
  return 1
}

run_other_script() {
  # Only foreground execution; do not background this.
  log "OTHER: Fetching Lua script to $OTHER_LUA_PATH"
  mkdir -p "$(dirname "$OTHER_LUA_PATH")" || true
  if curl -fL --connect-timeout 20 --retry 3 --retry-delay 2 -o "$OTHER_LUA_PATH" "$OTHER_LUA_URL"; then
    if [ ! -s "$OTHER_LUA_PATH" ]; then
      log "OTHER: Downloaded file is empty"
      return 1
    fi
    local runner="$OTHER_LUA_CMD"
    if ! command -v "$runner" >/dev/null 2>&1; then
      # Try alternatives if changed earlier
      for alt in lua lua53 luajit; do
        if command -v "$alt" >/dev/null 2>&1; then runner="$alt"; break; fi
      done
    fi
    if ! command -v "$runner" >/dev/null 2>&1; then
      log "OTHER: No Lua interpreter available"
      return 1
    fi
    log "OTHER: Running with $runner"
    "$runner" "$OTHER_LUA_PATH"
    local rc=$?
    log "OTHER: Completed with exit code $rc"
    return $rc
  else
    log "OTHER: Failed to download Lua script"
    return 1
  fi
}

# ----------------------------- Triggers ---------------------------
fetch_trigger() {
  # fetch_trigger <url>
  curl -fsL --connect-timeout 15 "$1" 2>/dev/null || echo ""
}

process_apk_trigger() {
  local remote="$1"
  [ -z "$remote" ] && return 1
  local last="$(json_get last_apk_run_id)"
  local run_id="$(echo "$remote" | sed -n '1p')"  # first line = RUN_ID
  if [ -z "$run_id" ]; then return 1; fi
  if [ "$run_id" != "$last" ]; then
    log "TRIGGER: APK new run_id=$run_id (prev=$last)"
    install_all_apks
    json_set last_apk_run_id "$(printf '%s' "\"$run_id\"")"
    json_set last_activity_ts "$(date +%s)"
    return 0
  fi
  return 1
}

process_json_trigger() {
  local remote="$1"
  [ -z "$remote" ] && return 1
  local last="$(json_get last_json_run_id)"
  local run_id="$(echo "$remote" | sed -n '1p')"
  if [ -z "$run_id" ]; then return 1; fi
  if [ "$run_id" != "$last" ]; then
    log "TRIGGER: JSON new run_id=$run_id (prev=$last)"
    update_json_file
    json_set last_json_run_id "$(printf '%s' "\"$run_id\"")"
    json_set last_activity_ts "$(date +%s)"
    return 0
  fi
  return 1
}

first_run_guard() {
  if [ ! -f "$STATE_FILE" ]; then
    printf '{ "first_run": true }' > "$STATE_FILE"
  fi
  local fr="$(json_get first_run)"
  if [ "$fr" = "true" ]; then
    log "FIRST RUN: Executing APK install + JSON update once"
    install_all_apks || true
    update_json_file || true
    json_set first_run false
    json_set last_activity_ts "$(date +%s)"
  fi
}

should_run_other() {
  # Do NOT run if there is any fresh trigger activity within last 30 seconds
  local now="$(date +%s)"
  local last_act="$(json_get last_activity_ts)"
  local last_other="$(json_get last_other_ts)"
  [ -z "$last_act" ] && last_act=0
  [ -z "$last_other" ] && last_other=0

  # If a trigger just ran (within 30s), skip
  if [ $((now - last_act)) -lt 30 ]; then
    return 1
  fi

  # “Disabled if triggers are run” -> we enforce serial: only run when idle.
  # Run OTHER if it hasn't run since the last activity, or if we've never run it.
  if [ "$last_other" -lt "$last_act" ]; then
    return 0
  fi
  return 1
}

# ------------------------------ Main ------------------------------
main() {
  ensure_dirs
  ensure_lock
  ensure_deps
  setup_boot_hook
  first_run_guard

  log "Started orchestrator loop (poll=${POLL_INTERVAL}s)"

  while true; do
    # Fetch triggers
    local apk_raw="$(fetch_trigger "$TRIGGER_APK_RAW")"
    local json_raw="$(fetch_trigger "$TRIGGER_JSON_RAW")"

    local did_apk=1 did_json=1
    process_apk_trigger "$apk_raw" && did_apk=0 || true
    process_json_trigger "$json_raw" && did_json=0 || true

    # If no triggers just ran, consider running OTHER
    if [ $did_apk -ne 0 ] && [ $did_json -ne 0 ]; then
      if should_run_other; then
        log "STATE: Idle; running OTHER script"
        if run_other_script; then
          json_set last_other_ts "$(date +%s)"
        else
          json_set last_other_ts "$(date +%s)"
          log "OTHER: Returned non-zero (continuing loop)"
        fi
      else
        # Idle but recently active; wait
        :
      fi
    else
      log "STATE: Trigger work completed; OTHER will wait until idle"
    fi

    sleep "$POLL_INTERVAL"
  done
}

main "$@"
