#!/data/data/com.termux/files/usr/bin/bash
set -Eeuo pipefail

# =========================
# Config (edit if you need)
# =========================
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# Triggers (use RAW URLs for reliable reads)
APK_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshClones.txt"
JSON_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshScript.txt"

JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"

# Target JSON path (contains spaces)
JSON_TARGET_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
JSON_TARGET_FILE="$JSON_TARGET_DIR/Grow a Garden.json"

# OTHER script (Lua)
OTHER_LUA_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"
OTHER_LUA_PATH="/sdcard/download/reconnect.lua"   # your requested path (lowercase "download")

# Timings
POLL_INTERVAL_SEC=30
KILL_GRACE_SEC=8
WATCH_INTERVAL_SEC=10

# Paths
APK_DIR="$HOME/apks"                  # per your rule: avoid /sdcard/Download for APKs
STATE_DIR="$HOME/.guardian_state"
LOG_DIR="$HOME/.logs"
LOG_FILE="$LOG_DIR/guardian.log"

mkdir -p "$APK_DIR" "$STATE_DIR" "$LOG_DIR" || true

# =============
# Logging utils
# =============
log() { printf '[%(%F %T)T] %s\n' -1 "$*" | tee -a "$LOG_FILE" >&2; }

# ===================
# Helper: safe curl
# ===================
dl_file() {
  # $1=url $2=out
  local url="$1" out="$2"
  curl -fL --connect-timeout 15 --max-time 120 --retry 3 --retry-delay 2 --retry-all-errors -o "$out" "$url"
}

fetch_text() {
  # $1=url; echoes trimmed content
  local url="$1"
  curl -fsSL --connect-timeout 10 --max-time 30 --retry 2 --retry-all-errors "$url" | tr -d '\r' | tr -d '\n' | tr -d ' \t'
}

# ========================
# Trigger read with state
# ========================
read_flag() {
  # $1=url $2=statefile
  local url="$1" statefile="$2"
  local val
  if ! val="$(fetch_text "$url" || true)"; then
    echo "X"
    return 0
  fi
  case "$val" in
    0|1) echo "$val" > "$statefile.current"; echo "$val";;
    *) echo "X";;
  esac
}

get_prev_flag() {
  # $1=statefile
  local state="$1"
  if [[ -f "$state.prev" ]]; then cat "$state.prev"; else echo "INIT"; fi
}

set_prev_flag() {
  # $1=statefile $2=value
  echo "$2" > "$1.prev"
}

# =========================
# APK installation helpers
# =========================
have_su() { command -v su >/dev/null 2>&1; }
try_pm_install() {
  local apk="$1"
  local rc=1

  if have_su; then
    if su -c "pm install -r \"$apk\"" >/dev/null 2>&1; then return 0; fi
    # Some environments need system user context
    if su -lp 2000 -c "pm install -r \"$apk\"" >/dev/null 2>&1; then return 0; fi
  fi

  if command -v pm >/dev/null 2>&1; then
    if pm install -r "$apk" >/dev/null 2>&1; then return 0; fi
  fi
  if command -v cmd >/dev/null 2>&1; then
    if cmd package install -r "$apk" >/dev/null 2>&1; then return 0; fi
  fi
  return $rc
}

process_apks() {
  log "APK: starting download + install for ${#APK_URLS[@]} APK(s)"
  for url in "${APK_URLS[@]}"; do
    local name="${url##*/}"
    local out="$APK_DIR/$name"
    log "APK: downloading $name"
    if dl_file "$url" "$out"; then
      log "APK: installing $name"
      if try_pm_install "$out"; then
        log "APK: installed $name; deleting file"
        rm -f -- "$out" || true
      else
        log "APK: FAILED to install $name; leaving file for inspection"
      fi
    else
      log "APK: FAILED to download $name"
    fi
  done
  log "APK: complete"
}

# =========================
# JSON replacement helpers
# =========================
validate_json_if_possible() {
  local file="$1"
  if command -v jq >/dev/null 2>&1; then
    jq -e . "$file" >/dev/null 2>&1
  else
    # no jq -> basic non-empty check
    [[ -s "$file" ]]
  fi
}

process_json() {
  log "JSON: downloading config"
  local tmp="$(mktemp)"
  if ! dl_file "$JSON_URL" "$tmp"; then
    log "JSON: download failed"
    rm -f "$tmp" || true
    return 1
  fi
  if ! validate_json_if_possible "$tmp"; then
    log "JSON: validation failed (empty or invalid JSON)"
    rm -f "$tmp" || true
    return 1
  fi
  mkdir -p "$JSON_TARGET_DIR" || true

  # Atomic-ish replace: write to temp then move
  local tmp_target="${JSON_TARGET_FILE}.tmp.$$"
  if cat "$tmp" > "$tmp_target"; then
    mv -f -- "$tmp_target" "$JSON_TARGET_FILE"
    log "JSON: replaced contents in: $JSON_TARGET_FILE"
  else
    log "JSON: failed to write to target"
    rm -f -- "$tmp_target" || true
  fi
  rm -f -- "$tmp" || true
}

# =========================
# OTHER (Lua) runner
# =========================
ensure_lua() {
  if command -v lua >/dev/null 2>&1; then return 0; fi
  log "Lua interpreter not found; attempting to install via pkg"
  if command -v pkg >/dev/null 2>&1; then
    if yes | pkg install -y lua >/dev/null 2>&1; then
      log "Lua installed"
      return 0
    fi
  fi
  log "Lua still missing; please install manually: pkg install -y lua"
  return 1
}

start_other_script_foreground_with_watcher() {
  # Download/update lua file
  mkdir -p "/sdcard/download" || true
  log "OTHER: downloading reconnect.lua"
  if ! dl_file "$OTHER_LUA_URL" "$OTHER_LUA_PATH"; then
    log "OTHER: failed to download reconnect.lua"
    return 1
  fi

  if ! ensure_lua; then
    log "OTHER: cannot run without lua"
    return 1
  fi

  # Start Lua in foreground (foreground job), with a watcher in background that can terminate it
  log "OTHER: starting lua script (foreground). Will stop if any trigger becomes 1."
  lua "$OTHER_LUA_PATH" &
  local lua_pid=$!

  # watcher in background
  (
    while kill -0 "$lua_pid" >/dev/null 2>&1; do
      sleep "$WATCH_INTERVAL_SEC"
      local a_flag
      local j_flag
      a_flag="$(fetch_text "$APK_TRIGGER_URL" || echo "X")"
      j_flag="$(fetch_text "$JSON_TRIGGER_URL" || echo "X")"
      if [[ "$a_flag" == "1" || "$j_flag" == "1" ]]; then
        log "OTHER: trigger=1 detected; stopping lua (pid $lua_pid) to run tasks"
        kill -TERM "$lua_pid" >/dev/null 2>&1 || true
        sleep "$KILL_GRACE_SEC"
        kill -KILL "$lua_pid" >/dev/null 2>&1 || true
        break
      fi
    done
  ) &

  wait "$lua_pid" || true
  log "OTHER: lua script exited"
}

# =========================
# Main supervisor loop
# =========================
APK_STATE="$STATE_DIR/apk"
JSON_STATE="$STATE_DIR/json"

# Initialize prev with current values (prevents accidental run on first start)
curr_apk="$(read_flag "$APK_TRIGGER_URL" "$APK_STATE")" || true
curr_json="$(read_flag "$JSON_TRIGGER_URL" "$JSON_STATE")" || true
set_prev_flag "$APK_STATE" "${curr_apk:-INIT}"
set_prev_flag "$JSON_STATE" "${curr_json:-INIT}"

log "Guardian started. Monitoring triggers. APK=$curr_apk JSON=$curr_json"
termux-wake-lock >/dev/null 2>&1 || true

while true; do
  # Read current and previous flags
  curr_apk="$(read_flag "$APK_TRIGGER_URL" "$APK_STATE")" || curr_apk="X"
  curr_json="$(read_flag "$JSON_TRIGGER_URL" "$JSON_STATE")" || curr_json="X"
  prev_apk="$(get_prev_flag "$APK_STATE")"
  prev_json="$(get_prev_flag "$JSON_STATE")"

  # Rising-edge detection: act only when 0->1 (or INIT->1)
  if [[ "$curr_apk" == "1" && "$prev_apk" != "1" ]]; then
    log "APK: rising edge (0->1) detected"
    process_apks || true
    # After processing, remember we processed '1'. User should flip to 0 then back to 1 for next run.
    set_prev_flag "$APK_STATE" "1"
  elif [[ "$curr_apk" == "0" && "$prev_apk" != "0" ]]; then
    set_prev_flag "$APK_STATE" "0"
  fi

  if [[ "$curr_json" == "1" && "$prev_json" != "1" ]]; then
    log "JSON: rising edge (0->1) detected"
    process_json || true
    set_prev_flag "$JSON_STATE" "1"
  elif [[ "$curr_json" == "0" && "$prev_json" != "0" ]]; then
    set_prev_flag "$JSON_STATE" "0"
  fi

  # If no tasks pending (neither flag is 1 rising), run OTHER script.
  # We run it until a trigger becomes 1; the watcher will stop it.
  # If triggers are already 1 but not rising (e.g., user forgot to reset),
  # we avoid re-running tasks, and we won't start OTHER while flags are 1.
  if [[ "$curr_apk" != "1" && "$curr_json" != "1" ]]; then
    start_other_script_foreground_with_watcher || true
    # After OTHER exits (either completed or got stopped), loop again
  else
    # Triggers at 1: wait for user to reset to 0 then back to 1 for next run.
    log "Waiting: triggers high (APK=$curr_apk JSON=$curr_json). OTHER is disabled."
    sleep "$POLL_INTERVAL_SEC"
  fi

  # Idle pause between cycles
  sleep "$POLL_INTERVAL_SEC"
done
