#!/usr/bin/env bash
# Termux Android Automation (Visible UI + Foreground Reconnect)
# - Android 10 / VMOS Cloud / Rooted (Magisk)
# - Shows download/installation output and reconnect.lua UI verbatim
# - Continuous loop with edge-triggered tasks
# - Termux:Boot hook (if installed)
# - Stores APKs in $HOME/apks (not /sdcard/Download)

# ---------------------------
# Config
# ---------------------------

APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# Triggers (try both raw forms for resilience)
APK_TRIGGER_RAW_1="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshClones.txt"
APK_TRIGGER_RAW_2="https://raw.githubusercontent.com/Anrd5/MyAppCollection/main/RefreshClones.txt"

JSON_TRIGGER_RAW_1="https://raw.githubusercontent.com/Anrd5/MyAppCollection/main/RefreshScript.txt"
JSON_TRIGGER_RAW_2="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshScript.txt"

# JSON
JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"
DEST_JSON_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
DEST_JSON_FILE="$DEST_JSON_DIR/Grow a Garden.json"

# Other (run in foreground, show full UI)
RECONNECT_LUA_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"
RECONNECT_LUA_PATH="/sdcard/download/reconnect.lua"

# Intervals
POLL_SECONDS=60
NET_TIMEOUT=15
RETRIES=3

# Paths
APKS_DIR="$HOME/apks"
STATE_DIR="$HOME/.termux-ops"
STATE_FILE="$STATE_DIR/state.env"
LOG_FILE="$STATE_DIR/automation.log"
BOOT_DIR="$HOME/.termux/boot"

# Colors
BOLD="$(printf '\033[1m')"
DIM="$(printf '\033[2m')"
GRN="$(printf '\033[32m')"
YEL="$(printf '\033[33m')"
RED="$(printf '\033[31m')"
C0="$(printf '\033[0m')"

# ---------------------------
# Helpers
# ---------------------------

banner() {
  printf "\n${BOLD}${GRN}===== %s =====${C0}\n" "$1"
}

info() {
  printf "${BOLD}[INFO]${C0} %s\n" "$1" | tee -a "$LOG_FILE"
}

warn() {
  printf "${YEL}[WARN] %s${C0}\n" "$1" | tee -a "$LOG_FILE"
}

err() {
  printf "${RED}[ERROR] %s${C0}\n" "$1" | tee -a "$LOG_FILE"
}

section() {
  printf "${DIM}---- %s ----${C0}\n" "$1" | tee -a "$LOG_FILE"
}

trim_01() {
  printf "%s" "$1" | tr -d '\r\n\t ' | sed -n 's/^\([01]\).*$/\1/p'
}

have_su() { command -v su >/dev/null 2>&1; }

pm_install() {
  local apk="$1"
  # Show full pm output (Success/Failure) to the terminal; no redirection.
  if have_su; then
    su -c "pm install -r \"$apk\"" && return 0
    su -c "pm install -r --user 0 \"$apk\"" && return 0
    return 1
  else
    pm install -r "$apk"
    return $?
  fi
}

# Use curl with visible progress for downloads; quiet only for trigger HEAD/first-line fetches.
curl_fetch_file() {
  # Visible progress bar to terminal
  # -L follow redirects, -# progress-bar, retries
  curl -L -# --connect-timeout "$NET_TIMEOUT" --retry "$RETRIES" --retry-delay 2 -o "$2" "$1"
}

curl_fetch_text_firstline() {
  # Quiet text fetch for triggers; returns first line
  curl -fsSL --connect-timeout "$NET_TIMEOUT" --retry "$RETRIES" --retry-delay 2 "$1" | { IFS= read -r first || true; printf "%s" "$first"; }
}

fetch_trigger() {
  local v
  v=$(curl_fetch_text_firstline "$1" | trim_01)
  [ -n "$v" ] || v=$(curl_fetch_text_firstline "$2" | trim_01)
  printf "%s" "$v"
}

ensure_dirs() {
  mkdir -p "$APKS_DIR" "$STATE_DIR"
  mkdir -p "$DEST_JSON_DIR" 2>/dev/null || true
  mkdir -p "/sdcard/download" 2>/dev/null || true
}

ensure_storage_permission() {
  if [ ! -w "/storage/emulated/0" ]; then
    warn "Requesting storage permission (termux-setup-storage). Please accept the Android prompt."
    termux-setup-storage || true
    sleep 2
  fi
}

load_state() {
  [ -f "$STATE_FILE" ] && . "$STATE_FILE"
  : "${FIRST_RUN:=1}"
  : "${APK_LAST_SEEN:=0}"
  : "${APK_CYCLE:=0}"
  : "${JSON_LAST_SEEN:=0}"
  : "${JSON_CYCLE:=0}"
  : "${OTHER_LAST_APK_CYCLE:=0}"
  : "${OTHER_LAST_JSON_CYCLE:=0}"
}

save_state() {
  cat >"$STATE_FILE".tmp <<EOF
FIRST_RUN=${FIRST_RUN}
APK_LAST_SEEN=${APK_LAST_SEEN}
APK_CYCLE=${APK_CYCLE}
JSON_LAST_SEEN=${JSON_LAST_SEEN}
JSON_CYCLE=${JSON_CYCLE}
OTHER_LAST_APK_CYCLE=${OTHER_LAST_APK_CYCLE}
OTHER_LAST_JSON_CYCLE=${OTHER_LAST_JSON_CYCLE}
EOF
  mv "$STATE_FILE".tmp "$STATE_FILE"
}

setup_boot_hook() {
  if [ -d "$BOOT_DIR" ]; then
    local wrapper="$BOOT_DIR/99-termux-automation.sh"
    if [ ! -f "$wrapper" ]; then
      cat >"$wrapper" <<'WRAP'
#!/data/data/com.termux/files/usr/bin/sh
# Termux:Boot launcher for automation
sleep 15
/data/data/com.termux/files/usr/bin/bash -lc "$HOME/termux_automation.sh"
WRAP
      chmod +x "$wrapper"
      info "Created Termux:Boot launcher at $wrapper"
    fi
  fi
}

wait_for_network() {
  local url="$APK_TRIGGER_RAW_1"
  local tries=0
  while ! curl -fsI --connect-timeout "$NET_TIMEOUT" "$url" >/dev/null 2>&1; do
    tries=$((tries+1))
    [ $tries -gt 20 ] && break
    warn "Waiting for network..."
    sleep 5
  done
}

# ---------------------------
# APK cycle (visible)
# ---------------------------

download_apks() {
  banner "Downloading APKs"
  local ok=0
  for u in "${APK_URLS[@]}"; do
    local fn="$APKS_DIR/$(basename "$u")"
    section "Downloading $(basename "$u")"
    if curl_fetch_file "$u" "$fn"; then
      info "Saved to $fn"
      ok=1
    else
      err "Failed to download: $u"
    fi
  done
  [ $ok -eq 1 ]
}

install_apks_and_clean() {
  banner "Installing APKs"
  local any_fail=0
  shopt -s nullglob
  for apk in "$APKS_DIR"/*.apk; do
    section "Installing $(basename "$apk")"
    if pm_install "$apk"; then
      info "Install OK: $(basename "$apk")"
      rm -f "$apk"
      info "Deleted APK after install."
    else
      err "Install failed: $(basename "$apk")"
      any_fail=1
      # Keep file for next cycle retry
    fi
  done
  shopt -u nullglob

  if [ $any_fail -eq 0 ]; then
    # Final sweep just in case
    rm -f "$APKS_DIR"/*.apk 2>/dev/null || true
    return 0
  else
    return 1
  fi
}

run_apk_cycle() {
  banner "APK cycle starting"
  if download_apks && install_apks_and_clean; then
    info "APK cycle completed successfully."
    return 0
  else
    warn "APK cycle completed with errors; will retry on next trigger."
    return 1
  fi
}

# ---------------------------
# JSON cycle (visible)
# ---------------------------

run_json_cycle() {
  banner "JSON cycle starting"
  ensure_storage_permission
  local tmp_json="$STATE_DIR/tmp.json"
  section "Downloading JSON"
  if curl_fetch_file "$JSON_URL" "$tmp_json"; then
    info "Downloaded JSON to $tmp_json"
    section "Replacing JSON at: $DEST_JSON_FILE"
    mkdir -p "$DEST_JSON_DIR" || true
    if mv -f "$tmp_json" "$DEST_JSON_FILE"; then
      info "Replaced contents successfully."
      return 0
    else
      err "Failed to move JSON into place. Check storage permission."
      rm -f "$tmp_json"
      return 1
    fi
  else
    err "Failed to download JSON from $JSON_URL"
    return 1
  fi
}

# ---------------------------
# OTHER: reconnect (foreground, show full UI)
# ---------------------------

should_run_other() {
  # Run only if both cycles progressed since the last OTHER run
  [ "$APK_CYCLE" -gt "$OTHER_LAST_APK_CYCLE" ] && [ "$JSON_CYCLE" -gt "$OTHER_LAST_JSON_CYCLE" ]
}

run_other_script() {
  banner "Running reconnect script (foreground)"
  section "Fetching reconnect.lua"
  if curl_fetch_file "$RECONNECT_LUA_URL" "$RECONNECT_LUA_PATH"; then
    info "Saved to $RECONNECT_LUA_PATH"
  else
    err "Failed to download reconnect.lua"
    return 1
  fi

  if ! command -v lua >/dev/null 2>&1; then
    err "lua interpreter not found. Install it with: pkg install lua"
    return 1
  fi

  section "Launching: lua $RECONNECT_LUA_PATH"
  # IMPORTANT: do NOT pipe or redirect; let its interface print directly to the terminal.
  lua "$RECONNECT_LUA_PATH"
  local rc=$?
  if [ $rc -eq 0 ]; then
    info "Reconnect script exited with code 0"
  else
    warn "Reconnect script exited with code $rc"
  fi
  return $rc
}

# ---------------------------
# First run behavior
# ---------------------------

initial_run() {
  banner "FIRST RUN: executing APK + JSON cycles unconditionally"
  local apk_ok=1 json_ok=1
  run_apk_cycle || apk_ok=0
  run_json_cycle || json_ok=0

  if [ $apk_ok -eq 1 ]; then APK_CYCLE=$((APK_CYCLE+1)); fi
  if [ $json_ok -eq 1 ]; then JSON_CYCLE=$((JSON_CYCLE+1)); fi
  save_state

  if should_run_other; then
    if run_other_script; then
      OTHER_LAST_APK_CYCLE=$APK_CYCLE
      OTHER_LAST_JSON_CYCLE=$JSON_CYCLE
      info "FIRST RUN: reconnect script completed."
    else
      warn "FIRST RUN: reconnect script failed; will try after next successful cycles."
    fi
  else
    warn "FIRST RUN: skipping reconnect (both APK and JSON must complete)."
  fi

  FIRST_RUN=0
  save_state
}

# ---------------------------
# Main
# ---------------------------

mkdir -p "$STATE_DIR"
touch "$LOG_FILE"
banner "Termux Automation starting"
info "Log file: $LOG_FILE"
ensure_dirs
setup_boot_hook
wait_for_network
load_state

if [ "$FIRST_RUN" -eq 1 ]; then
  initial_run
fi

banner "Entering continuous loop (every ${POLL_SECONDS}s)"
while :; do
  wait_for_network

  section "Fetching triggers"
  apk_trig="$(fetch_trigger "$APK_TRIGGER_RAW_1" "$APK_TRIGGER_RAW_2")"
  json_trig="$(fetch_trigger "$JSON_TRIGGER_RAW_1" "$JSON_TRIGGER_RAW_2")"

  # If empty (network hiccup), reuse last seen
  if [ -z "$apk_trig" ]; then apk_trig="$APK_LAST_SEEN"; fi
  if [ -z "$json_trig" ]; then json_trig="$JSON_LAST_SEEN"; fi

  info "APK trigger: $apk_trig (last: $APK_LAST_SEEN) | JSON trigger: $json_trig (last: $JSON_LAST_SEEN)"

  # Edge 0->1 runs
  if [ "$APK_LAST_SEEN" = "0" ] && [ "$apk_trig" = "1" ]; then
    banner "APK trigger edge 0->1 detected"
    if run_apk_cycle; then
      APK_CYCLE=$((APK_CYCLE+1))
    fi
  fi

  if [ "$JSON_LAST_SEEN" = "0" ] && [ "$json_trig" = "1" ]; then
    banner "JSON trigger edge 0->1 detected"
    if run_json_cycle; then
      JSON_CYCLE=$((JSON_CYCLE+1))
    fi
  fi

  APK_LAST_SEEN="$apk_trig"
  JSON_LAST_SEEN="$json_trig"
  save_state

  # Only run OTHER when both cycles advanced, and not while a trigger is actively at 1.
  if should_run_other; then
    if [ "$APK_LAST_SEEN" = "1" ] || [ "$JSON_LAST_SEEN" = "1" ]; then
      warn "Reconnect disabled while triggers are active (value 1). Waiting."
    else
      if run_other_script; then
        OTHER_LAST_APK_CYCLE=$APK_CYCLE
        OTHER_LAST_JSON_CYCLE=$JSON_CYCLE
        save_state
      else
        warn "Reconnect failed; will attempt again after next successful cycles."
      fi
    fi
  else
    section "Reconnect not eligible yet (needs APK_CYCLE>${OTHER_LAST_APK_CYCLE} and JSON_CYCLE>${OTHER_LAST_JSON_CYCLE})"
  fi

  sleep "$POLL_SECONDS"
done
