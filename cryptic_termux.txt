#!/usr/bin/env bash
# Cryptic Runner — Termux + tsu (root) automation for APKs, JSON, and reconnect.lua
# Android 10 / VMOS / Magisk + tsu
# - Runs continuously (foreground), started by Termux:Boot hook
# - Watches GitHub “trigger files” written by workflows (see below)
# - On first run: performs both APK and JSON tasks once
# - While reconnect.lua runs in foreground, a tiny watcher checks triggers and stops it if needed
# - APKs stored under $HOME/apks only (not on /sdcard)
# - After install, APKs are deleted
# - JSON update is atomic and validated
# - No zero exit codes when reconnect.lua terminates; it’s respawned unless triggers fire

set -Eeuo pipefail

# ------------------------------------------------------------------------------
# Configuration
# ------------------------------------------------------------------------------

# Paths and directories
PREFIX_DIR="${HOME}/.local"
STATE_DIR="${PREFIX_DIR}/state/cryptic"
RUN_DIR="${PREFIX_DIR}/run/cryptic"
LOG_DIR="${PREFIX_DIR}/share/cryptic/logs"
APK_DIR="${HOME}/apks"
TMP_DIR="${HOME}/.cache/cryptic"
LOCK_FILE="${RUN_DIR}/cryptic.lock"
STATE_FILE="${STATE_DIR}/triggers.json"
FIRST_RUN_MARK="${STATE_DIR}/.first_run"
RECONNECT_PID_FILE="${RUN_DIR}/reconnect.pid"

# JSON destination on shared storage (provided)
GARDEN_JSON_PATH="/storage/emulated/0/Cryptic/Workspace/SpeedHubX/Grow a Garden.json"

# Resources (provided)
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"

# Reconnect script (provided)
RECONNECT_LUA_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"
RECONNECT_LUA_PATH="/sdcard/download/reconnect.lua"

# GitHub trigger files (written by the workflows below)
TRIGGER_APK_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/.triggers/apk.json"
TRIGGER_JSON_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/.triggers/json.json"

# Poll interval for triggers (seconds)
POLL_SECONDS=20

# ------------------------------------------------------------------------------
# Utilities
# ------------------------------------------------------------------------------

log() {
  mkdir -p "${LOG_DIR}"
  printf "[%s] %s\n" "$(date -Iseconds)" "$*" | tee -a "${LOG_DIR}/runner.log"
}

die() {
  log "FATAL: $*"
  exit 1
}

ensure_dirs() {
  mkdir -p "${STATE_DIR}" "${RUN_DIR}" "${LOG_DIR}" "${APK_DIR}" "${TMP_DIR}"
}

require_root_via_tsu() {
  if [ "${EUID:-$(id -u)}" -ne 0 ]; then
    command -v tsu >/dev/null 2>&1 || die "tsu not installed. Install with: pkg install tsu"
    # Re-exec with root while preserving environment
    exec tsu -p -c "HOME='${HOME}' PATH='${PATH}' SHELL='${SHELL:-/data/data/com.termux/files/usr/bin/bash}' \"$0\""
  fi
}

ensure_prereqs() {
  # PATH additions typical for Termux + Android
  export PATH="/data/data/com.termux/files/usr/bin:/system/bin:/system/xbin:${PATH}"

  for cmd in curl jq pm lua; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      case "$cmd" in
        pm)  die "'pm' not found in PATH. Root shell should expose /system/bin. Check tsu/Root." ;;
        lua) log "Installing lua..."; pkg update -y >/dev/null 2>&1 || true; pkg install -y lua >/dev/null 2>&1 ;;
        jq)  log "Installing jq...";  pkg update -y >/dev/null 2>&1 || true; pkg install -y jq >/dev/null 2>&1 ;;
        curl) die "curl missing. Install with: pkg install curl" ;;
      esac
    fi
  done

  # Request storage access if needed
  if [ ! -d "/storage/emulated/0" ]; then
    log "Requesting shared storage permissions..."
    termux-setup-storage || true
  fi
}

with_lock() {
  exec 9>"${LOCK_FILE}"
  flock -n 9 || die "Another instance is running. Exiting."
}

curl_get() {
  # Reliable fetch with retries
  # $1=url, $2=output
  local url="$1" out="$2"
  curl -fL --retry 5 --retry-all-errors --connect-timeout 15 --max-time 0 -o "${out}.tmp" "$url"
  mv -f "${out}.tmp" "${out}"
}

# ------------------------------------------------------------------------------
# Trigger handling
# ------------------------------------------------------------------------------

load_state() {
  if [ -s "${STATE_FILE}" ]; then
    LAST_APK_TOKEN="$(jq -r '.apk // ""' "${STATE_FILE}" 2>/dev/null || echo "")"
    LAST_JSON_TOKEN="$(jq -r '.json // ""' "${STATE_FILE}" 2>/dev/null || echo "")"
  else
    LAST_APK_TOKEN=""
    LAST_JSON_TOKEN=""
  fi
}

save_state() {
  jq -n --arg apk "${LAST_APK_TOKEN}" --arg json "${LAST_JSON_TOKEN}" '{apk:$apk,json:$json}' > "${STATE_FILE}.tmp"
  mv -f "${STATE_FILE}.tmp" "${STATE_FILE}"
}

fetch_trigger_token() {
  # $1=url
  local url="$1" tmp="${TMP_DIR}/trigger.json"
  curl -fsSL --retry 3 --retry-all-errors --connect-timeout 10 "$url" -o "$tmp" || return 1
  # Expect a JSON containing at least {"token":"..."} but we also accept run_id/time combos
  local token
  token="$(jq -r '.token // .run_id // .time // empty' "$tmp" 2>/dev/null || true)"
  if [ -z "$token" ]; then
    # Fallback: hash the file content to get a stable change detector
    token="$(sha256sum "$tmp" | awk '{print $1}')"
  fi
  printf "%s" "$token"
}

check_triggers() {
  local apk_token json_token
  apk_token="$(fetch_trigger_token "${TRIGGER_APK_URL}" || echo "")"
  json_token="$(fetch_trigger_token "${TRIGGER_JSON_URL}" || echo "")"

  WANT_APK=0
  WANT_JSON=0

  if [ -n "$apk_token" ] && [ "$apk_token" != "$LAST_APK_TOKEN" ]; then
    WANT_APK=1
    LAST_APK_TOKEN="$apk_token"
  fi
  if [ -n "$json_token" ] && [ "$json_token" != "$LAST_JSON_TOKEN" ]; then
    WANT_JSON=1
    LAST_JSON_TOKEN="$json_token"
  fi
}

# ------------------------------------------------------------------------------
# APK workflow
# ------------------------------------------------------------------------------

download_apks() {
  log "Downloading APKs into ${APK_DIR} ..."
  for url in "${APK_URLS[@]}"; do
    local name
    name="$(basename "$url")"
    local dest="${APK_DIR}/${name}"
    log "  - $name"
    curl_get "$url" "$dest"
    # Sanity check size
    if [ ! -s "$dest" ]; then
      die "Downloaded file is empty: $dest"
    fi
  done
  log "All APKs downloaded."
}

install_apks() {
  log "Installing APKs via pm (root)..."
  local any=0
  for apk in "${APK_DIR}"/*.apk; do
    [ -e "$apk" ] || continue
    any=1
    log "  - pm install -r -g \"$apk\""
    # Grant runtime permissions on install (-g); replace if exists (-r)
    if pm install -r -g "$apk"; then
      log "    Installed: $(basename "$apk"). Deleting APK."
      rm -f "$apk"
    else
      log "    ERROR installing: $(basename "$apk"). Keeping file for inspection."
    fi
  done
  if [ "$any" -eq 0 ]; then
    log "No APKs present to install."
  else
    log "APK install phase completed."
  fi
}

# ------------------------------------------------------------------------------
# JSON workflow
# ------------------------------------------------------------------------------

update_json() {
  log "Updating JSON at: ${GARDEN_JSON_PATH}"
  local tmp_json="${TMP_DIR}/SpeedHubX.Config.json"
  curl_get "${JSON_URL}" "${tmp_json}"
  # Validate JSON
  if ! jq empty "${tmp_json}" 2>/dev/null; then
    die "Downloaded JSON is invalid."
  fi
  # Ensure destination dir exists
  local dest_dir
  dest_dir="$(dirname "${GARDEN_JSON_PATH}")"
  mkdir -p "${dest_dir}"

  # Atomic replace (write temp then move)
  local tmp_dest="${TMP_DIR}/Grow_a_Garden.json.tmp"
  cp -f "${tmp_json}" "${tmp_dest}"
  sync
  mv -f "${tmp_dest}" "${GARDEN_JSON_PATH}"
  sync
  log "JSON replaced successfully."
}

# ------------------------------------------------------------------------------
# Reconnect runner (foreground) with watcher
# ------------------------------------------------------------------------------

kill_reconnect_if_running() {
  if [ -f "${RECONNECT_PID_FILE}" ]; then
    local pid
    pid="$(cat "${RECONNECT_PID_FILE}" 2>/dev/null || echo "")"
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
      log "Stopping reconnect.lua (pid=${pid}) due to trigger..."
      kill -TERM "$pid" 2>/dev/null || true
      # Wait up to 10s for graceful stop
      for _ in $(seq 1 20); do
        kill -0 "$pid" 2>/dev/null || break
        sleep 0.5
      done
      # Force kill if still alive
      if kill -0 "$pid" 2>/dev/null; then
        log "Force killing reconnect.lua (pid=${pid})"
        kill -KILL "$pid" 2>/dev/null || true
      fi
    fi
    rm -f "${RECONNECT_PID_FILE}"
  fi
}

reconnect_watcher() {
  # Background watcher: polls triggers; if any change, kills reconnect
  # (Tiny process; reconnect itself remains foreground.)
  while :; do
    sleep "${POLL_SECONDS}"
    load_state
    local prev_apk="${LAST_APK_TOKEN}" prev_json="${LAST_JSON_TOKEN}"

    # Check remote tokens
    local cur_apk cur_json
    cur_apk="$(fetch_trigger_token "${TRIGGER_APK_URL}" || echo "")"
    cur_json="$(fetch_trigger_token "${TRIGGER_JSON_URL}" || echo "")"

    if { [ -n "$cur_apk" ] && [ "$cur_apk" != "$prev_apk" ]; } || \
       { [ -n "$cur_json" ] && [ "$cur_json" != "$prev_json" ]; }; then
      kill_reconnect_if_running
      return 0
    fi
  done
}

run_reconnect_foreground() {
  log "Starting reconnect.lua (foreground). It will only stop when triggers fire."

  # Ensure latest script downloaded to the specified path (kept as provided)
  mkdir -p "$(dirname "${RECONNECT_LUA_PATH}")"

  # Launch watcher in background
  reconnect_watcher &
  local watcher_pid=$!

  # Foreground loop: keep reconnect alive; never exit with code 0 on lua termination
  while :; do
    curl -fL --retry 5 --retry-all-errors --connect-timeout 15 -o "${RECONNECT_LUA_PATH}.tmp" "${RECONNECT_LUA_URL}" \
      && mv -f "${RECONNECT_LUA_PATH}.tmp" "${RECONNECT_LUA_PATH}" \
      || log "WARN: Failed to refresh reconnect.lua; will use existing file if present."

    if [ ! -s "${RECONNECT_LUA_PATH}" ]; then
      log "ERROR: reconnect.lua missing. Retrying in 5s..."
      sleep 5
      continue
    fi

    # Run lua (foreground)
    lua "${RECONNECT_LUA_PATH}" &
    local lua_pid=$!
    echo "${lua_pid}" > "${RECONNECT_PID_FILE}"

    # Wait for lua to exit or get killed by watcher
    wait "${lua_pid}"
    local rc=$?

    # Ensure non-zero exit code semantics when lua stops
    if [ "$rc" -eq 0 ]; then
      rc=1
    fi
    log "reconnect.lua terminated (rc=${rc})."

    # If watcher already killed it due to trigger, break to service tasks
    if ! kill -0 "${watcher_pid}" 2>/dev/null; then
      break
    fi

    # Unexpected exit; respawn after short pause
    sleep 2
  done

  rm -f "${RECONNECT_PID_FILE}" || true
}

# ------------------------------------------------------------------------------
# Main orchestration
# ------------------------------------------------------------------------------

cleanup() {
  rm -f "${RECONNECT_PID_FILE}" || true
}
trap cleanup EXIT

main() {
  ensure_dirs
  require_root_via_tsu
  ensure_prereqs
  with_lock

  # First-run enforcement: do both tasks once
  local do_first_run=0
  if [ ! -f "${FIRST_RUN_MARK}" ]; then
    do_first_run=1
    touch "${FIRST_RUN_MARK}"
    log "First run detected: APK and JSON tasks will run."
  fi

  load_state

  while :; do
    # Check triggers
    check_triggers

    local run_apk=0 run_json=0
    if [ "$do_first_run" -eq 1 ]; then
      run_apk=1
      run_json=1
      do_first_run=0
    else
      [ "${WANT_APK}" -eq 1 ] && run_apk=1
      [ "${WANT_JSON}" -eq 1 ] && run_json=1
    fi

    if [ "$run_apk" -eq 1 ] || [ "$run_json" -eq 1 ]; then
      # Disable reconnect while tasks run
      kill_reconnect_if_running

      if [ "$run_apk" -eq 1 ]; then
        log "=== APK TASK START ==="
        download_apks
        install_apks
        log "=== APK TASK DONE ==="
      fi

      if [ "$run_json" -eq 1 ]; then
        log "=== JSON TASK START ==="
        update_json
        log "=== JSON TASK DONE ==="
      fi

      # Persist trigger tokens we just serviced
      save_state

      # Loop back; if no other triggers pending, we’ll start reconnect again
    else
      # No tasks pending: run reconnect in foreground until triggers fire
      run_reconnect_foreground
      # After the watcher signals triggers, continue to process them
    fi

    # Small delay before next iteration (if tasks just ran, we’ll re-check immediately)
    sleep 2
  done
}

main "$@"
