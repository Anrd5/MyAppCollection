#!/data/data/com.termux/files/usr/bin/bash
# Cryptic Termux Controller
# - Continuous watcher for APK + JSON triggers via GitHub
# - Safe APK handling in $HOME/apks (not /sdcard/Download)
# - JSON replacement at /storage/emulated/0/Cryptic/Workspace/SpeedHubX/Grow a Garden.json
# - Runs "Other" reconnect.lua only when no new triggers fire
# - Uses tsu for privileged pm install
# - Hooks to Termux:Boot
# - Cleans up APKs after install
# - Robust curl with retries; explicit checks to avoid curl 22 surprises

set -Eeuo pipefail

# ----------------------------
# Config (edit if needed)
# ----------------------------
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"

# Trigger files written by the workflows in this repo (see below).
APK_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/triggers/apk.trigger"
JSON_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/triggers/json.trigger"

# Destination for JSON replacement (with spaces in file name)
DEST_JSON_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
DEST_JSON_FILE="${DEST_JSON_DIR}/Grow a Garden.json"

# Other-related script (foreground only; never background)
RECONNECT_DIR="/sdcard/download"
RECONNECT_LUA="${RECONNECT_DIR}/reconnect.lua"
RECONNECT_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"

# Polling interval (seconds)
POLL_INTERVAL=180

# ----------------------------
# Paths
# ----------------------------
ROOT="$HOME/cryptic"
BIN="$ROOT/bin"
APKS_DIR="$HOME/apks"
TMP_DIR="$ROOT/tmp"
STATE_DIR="$ROOT/state"
LOGS_DIR="$ROOT/logs"
BOOT_DIR="$HOME/.termux/boot"

APK_LAST_ID="$STATE_DIR/apk_last_id.txt"
JSON_LAST_ID="$STATE_DIR/json_last_id.txt"
FIRST_RUN_FLAG="$STATE_DIR/.first_run_done"

LOG_FILE="$LOGS_DIR/cryptic.log"

# ----------------------------
# Utils
# ----------------------------
log() {
  printf '%s %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" "$*" | tee -a "$LOG_FILE"
}

die() {
  log "FATAL: $*"
  exit 1
}

require_cmd() {
  local c="$1"
  command -v "$c" >/dev/null 2>&1 || die "Missing required command: $c"
}

ensure_dir() {
  mkdir -p "$1"
}

# Simple single-instance lock
LOCK_DIR="$STATE_DIR/.lock"
acquire_lock() {
  ensure_dir "$STATE_DIR"
  if mkdir "$LOCK_DIR" 2>/dev/null; then
    trap 'rm -rf "$LOCK_DIR"' EXIT
  else
    log "Another instance is running (lock present). Exiting."
    exit 0
  fi
}

# Robust curl download
# Usage: dl URL DEST
dl() {
  local url="$1"
  local dst="$2"
  curl -fSL --retry 5 --retry-all-errors --retry-delay 2 --connect-timeout 20 --max-time 600 -o "$dst" "$url"
}

# Root runner using tsu (preferred) or su
run_as_root() {
  local cmd="$*"
  if command -v tsu >/dev/null 2>&1; then
    tsu -c "$cmd"
  elif command -v su >/dev/null 2>&1; then
    su -c "$cmd"
  else
    die "No tsu/su available for root commands."
  fi
}

# Safe content replace
replace_file_contents() {
  local src="$1"
  local dest="$2"
  # Write via temp to avoid partial writes
  local tmp="${dest}.tmp.$$"
  cat "$src" > "$tmp"
  mv -f "$tmp" "$dest"
}

# Get RUN_ID from a trigger file
# The workflow writes lines like: RUN_ID=123456789
extract_run_id() {
  local file="$1"
  awk -F'=' '/^RUN_ID=/{print $2}' "$file" | tr -d '[:space:]'
}

# ----------------------------
# Environment preparation
# ----------------------------
prepare() {
  umask 022
  ensure_dir "$ROOT" "$BIN" "$APKS_DIR" "$TMP_DIR" "$STATE_DIR" "$LOGS_DIR" "$BOOT_DIR"

  # Logging header
  log "----- Cryptic Termux Controller start -----"

  # Required commands
  require_cmd curl
  require_cmd bash

  # Optional but needed for installs / run
  if ! command -v lua >/dev/null 2>&1; then
    log "lua not found; installing via pkg..."
    yes | pkg update || true
    yes | pkg install lua || die "Failed to install lua."
  fi

  if ! command -v tsu >/dev/null 2>&1; then
    log "tsu not found; installing via pkg..."
    yes | pkg install tsu || die "Failed to install tsu."
  fi

  # Storage access for /sdcard paths
  if [ ! -d "/sdcard" ]; then
    log "Requesting storage permission (termux-setup-storage)..."
    termux-setup-storage || die "termux-setup-storage failed."
  fi

  # Create Termux:Boot hook to re-run this script at boot
  local self_path="$ROOT/cryptic_main.sh"
  if [ ! -f "$self_path" ]; then
    # If running via pipe, save a copy of this script for boot reuse
    # Detect whether we have a file; if not, try to pull from your repo location later if you change paths.
    # For now, we write a minimal launcher that fetches the raw each boot if needed.
    cat > "$self_path" <<'EOF'
#!/data/data/com.termux/files/usr/bin/bash
set -Eeuo pipefail
ROOT="$HOME/cryptic"
MAIN="$ROOT/cryptic_main.sh"
RAW_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/cryptic_termux.txt"
mkdir -p "$ROOT" "$ROOT/logs"
LOG_FILE="$ROOT/logs/cryptic.log"
if [ ! -s "$MAIN" ]; then
  echo "$(date '+%F %T') Boot fetch: downloading main script..." | tee -a "$LOG_FILE"
  curl -fSL --retry 5 --retry-all-errors -o "$MAIN" "$RAW_URL" || exit 1
  chmod +x "$MAIN"
fi
exec "$MAIN"
EOF
    chmod +x "$self_path"
  fi

  # Boot script to start controller
  local boot_script="$BOOT_DIR/cryptic_boot.sh"
  cat > "$boot_script" <<EOF
#!/data/data/com.termux/files/usr/bin/bash
# Termux:Boot hook for Cryptic
termux-wake-lock || true
exec "$ROOT/cryptic_main.sh"
EOF
  chmod +x "$boot_script"

  # Ensure main copy equals this current file (if we are running the final script directly)
  # If this script has a filename, copy it to main path
  if [ -n "${BASH_SOURCE[0]:-}" ] && [ -f "${BASH_SOURCE[0]}" ]; then
    cp -f "${BASH_SOURCE[0]}" "$ROOT/cryptic_main.sh"
    chmod +x "$ROOT/cryptic_main.sh"
  fi
}

# ----------------------------
# APK handling
# ----------------------------
download_apks() {
  log "Downloading APKs to $APKS_DIR ..."
  local url
  for url in "${APK_URLS[@]}"; do
    local filename
    filename="$(basename "$url")"
    local dest="$APKS_DIR/$filename"
    log "Downloading: $filename"
    dl "$url" "$dest"
    log "OK: $filename"
  done
}

install_apks() {
  log "Installing APKs via pm (root)..."
  local apk
  for apk in "$APKS_DIR"/*.apk; do
    [ -e "$apk" ] || continue
    log "Installing: $(basename "$apk")"
    # Install for user 0, replace if present
    if run_as_root "pm install -r --user 0 \"$apk\""; then
      log "Installed: $(basename "$apk")"
      rm -f "$apk" || true
    else
      log "Install failed: $(basename "$apk")"
      # Keep the file for inspection; don't delete on failure
    fi
  done
}

process_apk_trigger() {
  local worked=0
  local tmp="$TMP_DIR/apk.trigger"
  if dl "$APK_TRIGGER_URL" "$tmp"; then
    local run_id
    run_id="$(extract_run_id "$tmp" || true)"
    if [ -z "${run_id:-}" ]; then
      log "APK trigger missing RUN_ID; skipping."
      echo "0" > "$APK_LAST_ID"
      echo 0
      return
    fi
    local last_id="0"
    if [ -f "$APK_LAST_ID" ]; then
      last_id="$(cat "$APK_LAST_ID" || echo 0)"
    fi
    if [ "$run_id" != "$last_id" ]; then
      log "New APK trigger detected (RUN_ID=$run_id, last=$last_id)."
      download_apks
      install_apks
      echo "$run_id" > "$APK_LAST_ID"
      worked=1
    else
      log "No new APK trigger (RUN_ID=$run_id)."
    fi
  else
    log "Failed to fetch APK trigger file."
  fi
  echo "$worked"
}

# ----------------------------
# JSON handling
# ----------------------------
download_and_replace_json() {
  ensure_dir "$DEST_JSON_DIR"
  local tmp_json="$TMP_DIR/SpeedHubX.Config.json"
  log "Downloading JSON..."
  dl "$JSON_URL" "$tmp_json"
  log "Replacing contents of: $DEST_JSON_FILE"
  # Ensure target file exists
  touch "$DEST_JSON_FILE"
  replace_file_contents "$tmp_json" "$DEST_JSON_FILE"
  log "JSON replacement completed."
}

process_json_trigger() {
  local worked=0
  local tmp="$TMP_DIR/json.trigger"
  if dl "$JSON_TRIGGER_URL" "$tmp"; then
    local run_id
    run_id="$(extract_run_id "$tmp" || true)"
    if [ -z "${run_id:-}" ]; then
      log "JSON trigger missing RUN_ID; skipping."
      echo "0" > "$JSON_LAST_ID"
      echo 0
      return
    fi
    local last_id="0"
    if [ -f "$JSON_LAST_ID" ]; then
      last_id="$(cat "$JSON_LAST_ID" || echo 0)"
    fi
    if [ "$run_id" != "$last_id" ]; then
      log "New JSON trigger detected (RUN_ID=$run_id, last=$last_id)."
      download_and_replace_json
      echo "$run_id" > "$JSON_LAST_ID"
      worked=1
    else
      log "No new JSON trigger (RUN_ID=$run_id)."
    fi
  else
    log "Failed to fetch JSON trigger file."
  fi
  echo "$worked"
}

# ----------------------------
# Other-related (reconnect.lua)
# ----------------------------
run_reconnect_script() {
  ensure_dir "$RECONNECT_DIR"
  log "Fetching reconnect.lua to $RECONNECT_LUA ..."
  dl "$RECONNECT_URL" "$RECONNECT_LUA"
  chmod 700 "$RECONNECT_LUA"
  log "Running reconnect.lua in foreground..."
  # Run until it completes successfully; if it errors, retry with backoff
  local attempt=1
  local sleep_s=5
  while true; do
    set +e
    lua "$RECONNECT_LUA"
    rc=$?
    set -e
    if [ "$rc" -eq 0 ]; then
      log "reconnect.lua completed successfully."
      return 0
    else
      log "reconnect.lua exited with code $rc. Retrying in ${sleep_s}s (attempt $attempt)..."
      sleep "$sleep_s"
      attempt=$((attempt+1))
      # Cap backoff to avoid runaway
      if [ "$sleep_s" -lt 60 ]; then
        sleep_s=$((sleep_s*2))
        [ "$sleep_s" -gt 60 ] && sleep_s=60
      fi
    fi
  done
}

# ----------------------------
# First-run behavior
# ----------------------------
do_first_run() {
  log "First run: executing both APK and JSON tasks once."
  download_apks
  install_apks
  download_and_replace_json
  # Initialize trigger state to current remote RUN_IDs so we don't re-run immediately
  if dl "$APK_TRIGGER_URL" "$TMP_DIR/apk.trigger"; then
    extract_run_id "$TMP_DIR/apk.trigger" > "$APK_LAST_ID" || echo "0" > "$APK_LAST_ID"
  else
    echo "0" > "$APK_LAST_ID"
  fi
  if dl "$JSON_TRIGGER_URL" "$TMP_DIR/json.trigger"; then
    extract_run_id "$TMP_DIR/json.trigger" > "$JSON_LAST_ID" || echo "0" > "$JSON_LAST_ID"
  else
    echo "0" > "$JSON_LAST_ID"
  fi
  touch "$FIRST_RUN_FLAG"
}

# ----------------------------
# Main loop
# ----------------------------
main() {
  prepare
  acquire_lock

  if [ ! -f "$FIRST_RUN_FLAG" ]; then
    do_first_run
  fi

  log "Entering watch loop. Poll interval: ${POLL_INTERVAL}s"
  while true; do
    local did_apk did_json
    did_apk="$(process_apk_trigger || echo 0)"
    did_json="$(process_json_trigger || echo 0)"

    # If either trigger ran this cycle, DO NOT run the "Other" script.
    if [ "$did_apk" -eq 0 ] && [ "$did_json" -eq 0 ]; then
      run_reconnect_script
    else
      log "Triggers ran this cycle (APK=$did_apk, JSON=$did_json); skipping reconnect.lua."
    fi

    log "Sleeping ${POLL_INTERVAL}s..."
    sleep "$POLL_INTERVAL"
  done
}

main
