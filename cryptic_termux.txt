#!/data/data/com.termux/files/usr/bin/bash
# cryptic_termux.sh
# Monitors a remote trigger and installs APKs on demand (Termux, Android).
# Robust argument parsing, downloader/root detection, logging, and daemonization.

set -Eeuo pipefail

# -----------------------------
# Defaults (override via args or env)
# -----------------------------
DAEMONIZE="${DAEMONIZE:-0}"
PIDFILE="${PIDFILE:-$HOME/.cache/cryptic_termux/cryptic_termux.pid}"
LOGFILE="${LOGFILE:-$HOME/.cache/cryptic_termux/cryptic_termux.log}"
STATE_DIR="${STATE_DIR:-$HOME/.cache/cryptic_termux}"
INSTALL_DIR="${INSTALL_DIR:-$HOME/Downloads/apks}"
POLL_INTERVAL="${POLL_INTERVAL:-60}"           # seconds
TRIGGER_URL="${TRIGGER_URL:-${CRYPTIC_TRIGGER_URL:-}}"
TEST_MODE="${TEST_MODE:-0}"
ONCE="${ONCE:-0}"
STOP_CMD=0
STATUS_CMD=0

# You can export CRYPTIC_TRIGGER_URL in your environment or pass --trigger=...
# Trigger formats supported:
# 1) JSON:
#    {"install":true,"apk_url":"https://example.com/app.apk","sha256":"...","nonce":"unique123"}
# 2) Plain text (KEY=VALUE per line):
#    INSTALL=1
#    APK_URL=https://example.com/app.apk
#    SHA256=...
#    NONCE=unique123

# -----------------------------
# Utilities
# -----------------------------
log() {
  local msg="[$(date +%Y-%m-%dT%H:%M:%S%z)] $*"
  echo "$msg" | tee -a "$LOGFILE" >/dev/null
}

die() {
  log "ERROR: $*"
  exit 1
}

usage() {
  cat <<EOF
Usage: $0 [options]

Options:
  --trigger=URL           Remote trigger URL (JSON or KEY=VALUE format). Required.
  --interval=SECONDS      Poll interval (default: $POLL_INTERVAL)
  --install-dir=DIR       Where to store downloaded APKs (default: $INSTALL_DIR)
  --logfile=FILE          Log file (default: $LOGFILE)
  --pidfile=FILE          PID file (default: $PIDFILE)
  --daemonize             Run in background and write PID file
  --once                  Perform one poll/installation cycle, then exit
  --stop                  Stop a running daemon (uses --pidfile)
  --status                Show daemon status (uses --pidfile)
  --test                  Dry-run (no installs), still downloads/verifies
  -h, --help              Show this help

Environment overrides:
  TRIGGER_URL or CRYPTIC_TRIGGER_URL, POLL_INTERVAL, INSTALL_DIR, LOGFILE, PIDFILE, STATE_DIR, DAEMONIZE, TEST_MODE

Examples:
  $0 --trigger=https://example.com/trigger.json --daemonize
  $0 --trigger=https://example.com/trigger.txt --interval=120 --install-dir="\$HOME/Downloads/apks"
EOF
}

ensure_dirs() {
  mkdir -p "$STATE_DIR" "$(dirname "$LOGFILE")" "$INSTALL_DIR"
  : > "$LOGFILE" || true
}

# -----------------------------
# Argument parsing (robust)
# -----------------------------
for arg in "$@"; do
  case "$arg" in
    --trigger=*) TRIGGER_URL="${arg#*=}" ;;
    --interval=*) POLL_INTERVAL="${arg#*=}" ;;
    --install-dir=*) INSTALL_DIR="${arg#*=}" ;;
    --logfile=*) LOGFILE="${arg#*=}" ;;
    --pidfile=*) PIDFILE="${arg#*=}" ;;
    --daemonize) DAEMONIZE=1 ;;
    --once) ONCE=1 ;;
    --stop) STOP_CMD=1 ;;
    --status) STATUS_CMD=1 ;;
    --test) TEST_MODE=1 ;;
    -h|--help) usage; exit 0 ;;
    *)
      echo "Unknown option: $arg"
      usage
      exit 1
      ;;
  esac
done

ensure_dirs

# -----------------------------
# Stop and status commands
# -----------------------------
if [[ "$STOP_CMD" -eq 1 ]]; then
  if [[ -f "$PIDFILE" ]]; then
    PID="$(cat "$PIDFILE" 2>/dev/null || true)"
    if [[ -n "${PID:-}" ]] && kill -0 "$PID" 2>/dev/null; then
      log "Stopping daemon PID $PID"
      kill "$PID" || true
      sleep 0.5
      if kill -0 "$PID" 2>/dev/null; then
        log "Force killing daemon PID $PID"
        kill -9 "$PID" || true
      fi
    else
      log "No active process for PID file: $PIDFILE"
    fi
    rm -f "$PIDFILE"
  else
    log "No PID file found at $PIDFILE"
  fi
  exit 0
fi

if [[ "$STATUS_CMD" -eq 1 ]]; then
  if [[ -f "$PIDFILE" ]]; then
    PID="$(cat "$PIDFILE" 2>/dev/null || true)"
    if [[ -n "${PID:-}" ]] && kill -0 "$PID" 2>/dev/null; then
      echo "Running (PID $PID)"
      exit 0
    else
      echo "Not running (stale PID file at $PIDFILE)"
      exit 1
    fi
  else
    echo "Not running"
    exit 1
  fi
fi

# -----------------------------
# Preconditions and helpers
# -----------------------------
# Downloader detection
DL_TOOL=""
if command -v wget >/dev/null 2>&1; then
  DL_TOOL="wget"
elif command -v curl >/dev/null 2>&1; then
  DL_TOOL="curl"
else
  log "No downloader found. Installing wget..."
  if command -v pkg >/dev/null 2>&1; then
    yes | pkg update -y || true
    yes | pkg install -y wget || die "Failed to install wget"
    DL_TOOL="wget"
  else
    die "Neither wget nor curl is available, and 'pkg' not found."
  fi
fi

dl_to_file() {
  local url="$1" out="$2"
  case "$DL_TOOL" in
    wget) wget -q --show-progress -O "$out" "$url" ;;
    curl) curl -fL --progress-bar -o "$out" "$url" ;;
  esac
}

dl_to_stdout() {
  local url="$1"
  case "$DL_TOOL" in
    wget) wget -q -O - "$url" ;;
    curl) curl -fsSL "$url" ;;
  esac
}

# JSON parser (jq optional)
JQ=""
if command -v jq >/dev/null 2>&1; then
  JQ="jq"
else
  log "jq not found. JSON trigger support will be limited. Attempting install..."
  if command -v pkg >/dev/null 2>&1; then
    yes | pkg install -y jq || log "jq install failed; will fallback to plain-text parsing."
    if command -v jq >/dev/null 2>&1; then JQ="jq"; fi
  fi
fi

# Root detection
ROOT_CMD=""
if command -v tsu >/dev/null 2>&1; then
  ROOT_CMD="tsu -c"
elif command -v su >/dev/null 2>&1; then
  ROOT_CMD="su -c"
else
  log "No root helper (tsu/su) found. APK installation will likely fail without manual confirmation."
  # We allow continuing in TEST_MODE or for users who handle installs another way.
fi

# pm presence
if ! command -v pm >/dev/null 2>&1; then
  log "'pm' command not found. Are you running in Android shell? Installation may not work."
fi

# sha256sum presence
if ! command -v sha256sum >/dev/null 2>&1; then
  log "sha256sum not found. Attempting to install coreutils..."
  if command -v pkg >/dev/null 2>&1; then
    yes | pkg install -y coreutils || log "coreutils install failed; checksum verification unavailable."
  fi
fi

# -----------------------------
# Trigger parsing
# -----------------------------
parse_trigger() {
  # Reads trigger content from stdin, writes parsed values to env:
  #   PARSE_INSTALL=0/1, PARSE_APK_URL, PARSE_SHA256 (optional), PARSE_NONCE (optional)
  local content
  content="$(cat)"

  local install=""; local apk_url=""; local sha256=""; local nonce=""

  if [[ -n "$JQ" ]] && echo "$content" | $JQ . >/dev/null 2>&1; then
    # JSON mode
    install="$(echo "$content" | $JQ -r '(.install // .INSTALL // .enabled // .ENABLED // false) | tostring' 2>/dev/null || echo "")"
    apk_url="$(echo "$content" | $JQ -r '(.apk_url // .APK_URL // "")' 2>/dev/null || echo "")"
    sha256="$(echo "$content" | $JQ -r '(.sha256 // .SHA256 // "")' 2>/dev/null || echo "")"
    nonce="$(echo "$content" | $JQ -r '(.nonce // .NONCE // .version // .VERSION // "")' 2>/dev/null || echo "")"
  else
    # Plain text KEY=VALUE mode
    install="$(echo "$content" | awk -F= '/^(INSTALL|install|ENABLED|enabled)=/ {print $2; exit}')"
    apk_url="$(echo "$content" | awk -F= '/^(APK_URL|apk_url)=/ {print $2; exit}')"
    sha256="$(echo "$content" | awk -F= '/^(SHA256|sha256)=/ {print $2; exit}')"
    nonce="$(echo "$content" | awk -F= '/^(NONCE|nonce|VERSION|version)=/ {print $2; exit}')"
  fi

  # Normalize booleans
  case "${install,,}" in
    1|y|yes|true|on|enable|enabled) install="1" ;;
    0|n|no|false|off|disable|disabled|"") install="0" ;;
    *) install="0" ;;
  esac

  echo "PARSE_INSTALL=$install"
  echo "PARSE_APK_URL=$apk_url"
  echo "PARSE_SHA256=$sha256"
  echo "PARSE_NONCE=$nonce"
}

# -----------------------------
# APK handling
# -----------------------------
verify_sha256() {
  local file="$FILE"
  local expect="$EXPECTED"
  if [[ -z "${expect:-}" ]]; then
    echo "OK (no checksum provided)"
    return 0
  fi
  if ! command -v sha256sum >/dev/null 2>&1; then
    echo "SKIP (sha256sum unavailable)"
    return 0
  fi
  local got
  got="$(sha256sum "$file" | awk '{print $1}')"
  if [[ "${got,,}" == "${expect,,}" ]]; then
    echo "OK"
    return 0
  else
    echo "MISMATCH (got $got)"
    return 1
  fi
}

install_apk() {
  local apk="$1"
  if [[ "$TEST_MODE" -eq 1 ]]; then
    log "[TEST] Would install: $apk"
    return 0
  fi
  if [[ -n "$ROOT_CMD" ]]; then
    # Try modern 'cmd package' first, then fallback to 'pm'
    if $ROOT_CMD "cmd package install -r --user 0 \"$apk\""; then
      log "Installed via 'cmd package': $apk"
      return 0
    elif $ROOT_CMD "pm install -r --user 0 \"$apk\""; then
      log "Installed via 'pm install': $apk"
      return 0
    else
      die "Rooted installation failed for: $apk"
    fi
  else
    # Non-root: this may prompt or fail depending on environment
    if pm install -r --user 0 "$apk"; then
      log "Installed without root (pm): $apk"
      return 0
    else
      die "Installation failed (no root). Consider installing 'tsu' via 'pkg install tsu'."
    fi
  fi
}

# -----------------------------
# Monitor loop
# -----------------------------
LAST_NONCE_FILE="$STATE_DIR/last_nonce"
process_trigger_once() {
  [[ -z "$TRIGGER_URL" ]] && die "No --trigger URL provided."

  local tmp_trig
  tmp_trig="$(mktemp "$STATE_DIR/trigger.XXXXXX")"
  trap 'rm -f "$tmp_trig"' RETURN

  if ! dl_to_file "$TRIGGER_URL" "$tmp_trig"; then
    log "Failed to fetch trigger from: $TRIGGER_URL"
    return 1
  fi

  # Parse
  eval "$(cat "$tmp_trig" | parse_trigger)"
  local install="$PARSE_INSTALL"
  local apk_url="$PARSE_APK_URL"
  local sha256="$PARSE_SHA256"
  local nonce="$PARSE_NONCE"

  log "Trigger: install=$install apk_url=${apk_url:-<none>} sha256=${sha256:+provided} nonce=${nonce:-<none>}"

  # Nonce gating: avoid repeat installs
  local last_nonce=""
  if [[ -f "$LAST_NONCE_FILE" ]]; then
    last_nonce="$(cat "$LAST_NONCE_FILE" 2>/dev/null || true)"
  fi
  if [[ -n "$nonce" && "$nonce" == "$last_nonce" ]]; then
    log "Nonce unchanged; nothing to do."
    return 0
  fi

  if [[ "$install" != "1" ]]; then
    log "Install flag not set; nothing to do."
    return 0
  fi

  if [[ -z "$apk_url" ]]; then
    log "Install requested but APK_URL missing."
    return 1
  fi

  # Download APK
  local base name out
  base="$(basename "$apk_url")"
  # Ensure .apk suffix for clarity
  if [[ "$base" != *.apk ]]; then
    name="${base}.apk"
  else
    name="$base"
  fi
  out="$INSTALL_DIR/$name"

  log "Downloading APK: $apk_url -> $out"
  if ! dl_to_file "$apk_url" "$out"; then
    log "Failed to download APK."
    return 1
  fi

  # Verify checksum if provided
  if [[ -n "$sha256" ]]; then
    local FILE="$out" EXPECTED="$sha256"
    local verdict
    verdict="$(verify_sha256)"
    if [[ "$verdict" != "OK" && "$verdict" != "OK (no checksum provided)" && "$verdict" != "SKIP (sha256sum unavailable)" ]]; then
      log "Checksum verification failed: $verdict"
      return 1
    else
      log "Checksum: $verdict"
    fi
  fi

  # Install
  install_apk "$out"

  # Update nonce on success
  if [[ -n "$nonce" ]]; then
    echo -n "$nonce" > "$LAST_NONCE_FILE"
  else
    # If no nonce, record last filename to avoid re-installing same file consecutively
    echo -n "$name" > "$LAST_NONCE_FILE"
  fi

  log "Done."
  return 0
}

monitor_loop() {
  log "Starting monitor loop. Interval=${POLL_INTERVAL}s Trigger=${TRIGGER_URL}"
  while true; do
    if ! process_trigger_once; then
      log "Cycle completed with errors."
    fi
    if [[ "$ONCE" -eq 1 ]]; then
      break
    fi
    sleep "$POLL_INTERVAL"
  done
  log "Monitor loop exiting."
}

daemonize() {
  if [[ -f "$PIDFILE" ]]; then
    local oldpid
    oldpid="$(cat "$PIDFILE" 2>/dev/null || true)"
    if [[ -n "$oldpid" ]] && kill -0 "$oldpid" 2>/dev/null; then
      die "Daemon already running (PID $oldpid). Use --stop first."
    else
      log "Removing stale PID file."
      rm -f "$PIDFILE"
    fi
  fi

  # Start background process with its own session
  log "Daemonizing..."
  setsid bash -c "
    trap 'exit 0' INT TERM
    exec \"$0\" --trigger=\"$TRIGGER_URL\" --interval=\"$POLL_INTERVAL\" --install-dir=\"$INSTALL_DIR\" --logfile=\"$LOGFILE\" --pidfile=\"$PIDFILE\" ${TEST_MODE:+--test} ${ONCE:+--once}
  " >/dev/null 2>&1 &

  echo $! > "$PIDFILE"
  disown || true
  log "Daemon started (PID $(cat "$PIDFILE"))."
}

# -----------------------------
# Run
# -----------------------------
if [[ -z "$TRIGGER_URL" ]]; then
  usage
  die "Missing required --trigger URL."
fi

# Basic URL sanity
if [[ ! "$TRIGGER_URL" =~ ^https?:// ]]; then
  die "Trigger URL must be http(s). Got: $TRIGGER_URL"
fi

if [[ "$DAEMONIZE" -eq 1 ]]; then
  daemonize
  exit 0
else
  trap 'log "Interrupted"; exit 130' INT
  trap 'log "Terminated"; exit 143' TERM
  monitor_loop
fi
