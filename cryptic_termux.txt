#!/data/data/com.termux/files/usr/bin/bash
# cryptic-watcher.sh — Continuous watcher for APK/JSON triggers plus controlled reconnect.lua
# Android 10 • Termux • Root available via su (VMOS Cloud / Magisk)
# Stable, idempotent, logs everything, plays nice with Termux:Boot.

set -Eeuo pipefail
IFS=$'\n\t'

# ------------- CONFIG -------------
APK_DIR="$HOME/apks"
STATE_DIR="$HOME/.local/state/cryptic-watcher"
LOG_FILE="$STATE_DIR/cryptic-watcher.log"
TMP_DIR="$HOME/.tmp/cryptic-watcher"
CHECK_INTERVAL="${CHECK_INTERVAL:-30}"  # seconds between polls
NET_RETRIES=5
NET_TIMEOUT=30

# Triggers (raw)
APK_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshClones.txt"
JSON_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshScript.txt"

# APKs to download and install (Termux private dir; do NOT use /sdcard/Download)
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# JSON download source and destination
JSON_SRC_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"
JSON_DEST_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
JSON_DEST_FILE="$JSON_DEST_DIR/Grow a Garden.json"

# OTHER script (run only when both triggers idle)
RECONNECT_LUA_PATH="/sdcard/download/reconnect.lua"
RECONNECT_LUA_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"

# ------------- STATE FILES -------------
LAST_APK_TRIGGER="$STATE_DIR/last_apk_trigger.txt"
LAST_JSON_TRIGGER="$STATE_DIR/last_json_trigger.txt"
RECONNECT_PID_FILE="$STATE_DIR/reconnect.pid"

# ------------- UTIL -------------
log() {
  mkdir -p "$(dirname "$LOG_FILE")"
  printf "[%(%Y-%m-%d %H:%M:%S)T] %s\n" -1 "$*" | tee -a "$LOG_FILE"
}

trim1() {
  sed -n 's/^[[:space:]]*//;s/[[:space:]]*$//;1s/^\(.\).*$/\1/p'
}

have_cmd() { command -v "$1" >/dev/null 2>&1; }

require_root() {
  if have_cmd su; then
    true
  else
    log "WARNING: su not found. APK installs may fail without root."
  fi
}

pm_install() {
  local apk_path="$1"
  if have_cmd su; then
    su -c "pm install -r '$apk_path'"
  else
    pm install -r "$apk_path"
  fi
}

ensure_dirs() {
  mkdir -p "$APK_DIR" "$STATE_DIR" "$TMP_DIR" "$JSON_DEST_DIR"
}

get_trigger() {
  # $1 url
  local url="$1"
  curl -fsSL --max-time "$NET_TIMEOUT" --retry "$NET_RETRIES" --retry-all-errors "$url" | trim1 || echo "0"
}

download_file() {
  # $1 url, $2 dest
  local url="$1" dest="$2"
  curl -fL --retry "$NET_RETRIES" --retry-all-errors --connect-timeout 10 --max-time 0 -o "$dest" "$url"
}

validate_json() {
  # $1 path
  jq empty "$1" >/dev/null 2>&1
}

wake_lock_acquire() {
  if have_cmd termux-wake-lock; then
    termux-wake-lock || true
  fi
}
wake_lock_release() {
  if have_cmd termux-wake-unlock; then
    termux-wake-unlock || true
  fi
}

# ------------- JOBS -------------
run_apk_job() {
  log "APK job: starting downloads to $APK_DIR"
  for url in "${APK_URLS[@]}"; do
    local fname dest
    fname="$(basename "$url")"
    dest="$APK_DIR/$fname"
    log "Downloading $url -> $dest"
    download_file "$url" "$dest"
    log "Downloaded $fname"
    log "Installing $fname"
    if pm_install "$dest"; then
      log "Installed $fname successfully."
    else
      log "ERROR installing $fname. Will continue with next."
    fi
  done
  log "APK job: completed."
}

run_json_job() {
  local tmp_json="$TMP_DIR/SpeedHubX.Config.json"
  log "JSON job: downloading $JSON_SRC_URL"
  download_file "$JSON_SRC_URL" "$tmp_json"
  if validate_json "$tmp_json"; then
    log "JSON job: valid JSON, writing to: $JSON_DEST_FILE"
    # Replace file atomically
    cp -f "$tmp_json" "$JSON_DEST_FILE"
    log "JSON job: replacement complete."
  else
    log "ERROR: Downloaded JSON is invalid. Skipping overwrite."
  fi
}

start_reconnect() {
  # Start reconnect.lua and record PID; ensure we can stop it later.
  # Always refresh the lua file before starting.
  log "OTHER: Fetching reconnect.lua -> $RECONNECT_LUA_PATH"
  download_file "$RECONNECT_LUA_URL" "$RECONNECT_LUA_PATH"
  chmod 0644 "$RECONNECT_LUA_PATH" || true

  if ! have_cmd lua; then
    log "Lua not found; attempting to install via pkg."
    pkg install -y lua || true
  fi

  # Launch in supervised background so we can stop it if triggers flip.
  # Note: It runs in the foreground of its own process; we only supervise the PID.
  log "OTHER: starting lua $RECONNECT_LUA_PATH"
  nohup lua "$RECONNECT_LUA_PATH" >>"$LOG_FILE" 2>&1 &
  echo $! > "$RECONNECT_PID_FILE"
  log "OTHER: reconnect.lua started with PID $(cat "$RECONNECT_PID_FILE")"
}

stop_reconnect() {
  if [[ -f "$RECONNECT_PID_FILE" ]]; then
    local pid
    pid="$(cat "$RECONNECT_PID_FILE" || true)"
    if [[ -n "${pid:-}" ]] && kill -0 "$pid" 2>/dev/null; then
      log "OTHER: stopping reconnect.lua (PID $pid)"
      kill "$pid" 2>/dev/null || true
      # Give it a moment, then force if needed
      sleep 2
      if kill -0 "$pid" 2>/dev/null; then
        kill -9 "$pid" 2>/dev/null || true
      end_if=true
      log "OTHER: reconnect.lua stopped."
    fi
    rm -f "$RECONNECT_PID_FILE"
  fi
}

reconnect_running() {
  [[ -f "$RECONNECT_PID_FILE" ]] && kill -0 "$(cat "$RECONNECT_PID_FILE" 2>/dev/null || echo 0)" 2>/dev/null
}

# ------------- MAIN LOOP -------------
cleanup() {
  log "Cleanup requested. Stopping reconnect (if running) and releasing wake-lock."
  stop_reconnect
  wake_lock_release
}
trap cleanup SIGINT SIGTERM

main() {
  ensure_dirs
  wake_lock_acquire
  require_root

  # Seed last-known trigger states if missing
  [[ -f "$LAST_APK_TRIGGER" ]] || echo "0" > "$LAST_APK_TRIGGER"
  [[ -f "$LAST_JSON_TRIGGER" ]] || echo "0" > "$LAST_JSON_TRIGGER"

  log "Watcher started. Interval=${CHECK_INTERVAL}s"
  log "APK dir: $APK_DIR"
  log "JSON dest: $JSON_DEST_FILE"

  while true; do
    # Read triggers
    apk_trigger="$(get_trigger "$APK_TRIGGER_URL" || echo 0)"
    json_trigger="$(get_trigger "$JSON_TRIGGER_URL" || echo 0)"

    last_apk="$(cat "$LAST_APK_TRIGGER" 2>/dev/null || echo 0)"
    last_json="$(cat "$LAST_JSON_TRIGGER" 2>/dev/null || echo 0)"

    # Check transitions for jobs (0 -> 1 runs once)
    apk_should_run=false
    json_should_run=false

    if [[ "$apk_trigger" == "1" && "$last_apk" != "1" ]]; then
      apk_should_run=true
    fi
    if [[ "$json_trigger" == "1" && "$last_json" != "1" ]]; then
      json_should_run=true
    fi

    # If any trigger is active (==1), ensure OTHER script is disabled
    if [[ "$apk_trigger" == "1" || "$json_trigger" == "1" ]]; then
      if reconnect_running; then
        log "Trigger active -> disabling OTHER script."
        stop_reconnect
      fi
    fi

    # Run jobs in order: APK -> JSON; they won’t interfere with OTHER.
    if [[ "$apk_should_run" == true ]]; then
      log "APK trigger 0->1 detected."
      run_apk_job || log "APK job encountered errors."
      echo "1" > "$LAST_APK_TRIGGER"
    else
      # Keep last value mirrored to current (so going 1->0 is noted)
      echo "$apk_trigger" > "$LAST_APK_TRIGGER"
    fi

    if [[ "$json_should_run" == true ]]; then
      log "JSON trigger 0->1 detected."
      run_json_job || log "JSON job encountered errors."
      echo "1" > "$LAST_JSON_TRIGGER"
    else
      echo "$json_trigger" > "$LAST_JSON_TRIGGER"
    fi

    # If both triggers are idle (==0) and OTHER not running, start it.
    if [[ "$apk_trigger" == "0" && "$json_trigger" == "0" ]]; then
      if ! reconnect_running; then
        log "Both jobs idle -> starting OTHER script."
        start_reconnect || log "Failed to start OTHER script."
      fi
    fi

    # If either trigger flips to 1 while OTHER is running, it’ll be stopped next loop.
    sleep "$CHECK_INTERVAL"
  done
}

main "$@"
