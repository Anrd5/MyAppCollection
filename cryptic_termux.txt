#!/data/data/com.termux/files/usr/bin/bash
# cryptic_runner.sh — Standalone Termux foreground runner
# - Foreground only (no backgrounding)
# - Hooks to Termux:Boot via a small launcher (see instructions below)
# - Detects GitHub workflow-triggered changes to run APK/JSON tasks once per run
# - Runs reconnect.lua in foreground and ensures it never returns exit code 0
# - Avoids storing APKs under /sdcard/Download (uses $HOME/apks)
# - Deletes APKs after successful install

umask 022
set -u -o pipefail

# ---------------- Configuration ----------------
# APK direct links (provided)
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# JSON source and destination
JSON_SRC_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"
JSON_DEST_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
JSON_DEST_FILE="${JSON_DEST_DIR}/Grow a Garden.json"

# GitHub trigger files (updated by workflows below)
# These are polled by this script; each content change = one run
TRIGGER_APK_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/.triggers/apk.trigger"
TRIGGER_JSON_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/.triggers/json.trigger"

# Other Related
RECONNECT_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"
RECONNECT_PATH="/sdcard/download/reconnect.lua"  # Use the path you provided

# Polling / retry behavior
POLL_INTERVAL_SEC=120
CURL_OPTS=(--fail --location --retry 3 --retry-connrefused --connect-timeout 10 --max-time 120)

# ---------------- Paths & state ----------------
STATE_DIR="$HOME/.cryptic/state"
TMP_DIR="$HOME/.cryptic/tmp"
LOG_DIR="$HOME/.cryptic/logs"
APK_DIR="$HOME/apks"

LAST_APK_SIG_FILE="${STATE_DIR}/last_apk_trigger.sig"
LAST_JSON_SIG_FILE="${STATE_DIR}/last_json_trigger.sig"
FIRST_RUN_FLAG="${STATE_DIR}/first_run_done"

mkdir -p "$STATE_DIR" "$TMP_DIR" "$LOG_DIR" "$APK_DIR"

# Singleton lock (foreground only; prevents parallel runs)
exec 9>"${STATE_DIR}/.runner.lock"
if ! flock -n 9; then
  echo "[ERR] Another instance is already running. Exiting." >&2
  exit 1
fi

# ---------------- Helpers ----------------
log() {
  printf "[%s] %s\n" "$(date -u +'%Y-%m-%dT%H:%M:%SZ')" "$*" | tee -a "${LOG_DIR}/runner.log"
}
err() {
  printf "[%s] ERROR: %s\n" "$(date -u +'%Y-%m-%dT%H:%M:%SZ')" "$*" | tee -a "${LOG_DIR}/runner.log" >&2
}
need_cmd() { command -v "$1" >/dev/null 2>&1 || { err "Missing command: $1"; return 1; }; }

http_fetch_to() {
  # $1=url $2=output_path
  curl "${CURL_OPTS[@]}" -o "$2" "$1"
}

sha256_of_file() {
  sha256sum "$1" | awk '{print $1}'
}

ensure_storage_ready() {
  if [ ! -d "/storage/emulated/0" ]; then
    log "Requesting storage permission (termux-setup-storage). Approve on device."
    termux-setup-storage || true
    # Wait briefly for mount
    sleep 3
  fi
  if [ ! -d "/storage/emulated/0" ]; then
    err "External storage not available. JSON replace may fail."
  fi
}

require_root() {
  if ! command -v su >/dev/null 2>&1; then
    err "Root (su) not available; cannot install APKs silently."
    return 1
  fi
  return 0
}

# ---------------- Triggers ----------------
read_remote_sig() {
  # $1=url, writes tmp file, echoes sha256 hash to stdout
  local _url="$1"
  local _tmp="${TMP_DIR}/sig.$RANDOM.$RANDOM"
  if http_fetch_to "$_url" "$_tmp"; then
    sha256_of_file "$_tmp"
    rm -f "$_tmp"
    return 0
  else
    err "Failed to fetch trigger: $_url"
    rm -f "$_tmp"
    return 1
  fi
}

trigger_changed() {
  # $1=url, $2=last_sig_file
  local _url="$1" _sig_file="$2"
  local _sig
  _sig="$(read_remote_sig "$_url")" || return 1
  if [ ! -f "$_sig_file" ]; then
    echo "$_sig" > "$_sig_file"
    echo "first"  # treat as changed on first observation
    return 0
  fi
  local _prev
  _prev="$(cat "$_sig_file" 2>/dev/null || true)"
  if [ "$_prev" != "$_sig" ]; then
    echo "$_sig" > "$_sig_file"
    echo "changed"
  else
    echo "same"
  fi
  return 0
}

# ---------------- APK handling ----------------
install_apk_file() {
  # $1=path to apk
  local _apk="$1"
  # Use root package manager for silent install
  if require_root; then
    # Some systems require temp copy under /data/local/tmp for pm to ingest.
    local _tmp_apk="/data/local/tmp/$(basename "$_apk")"
    su -c "cp -f '$_apk' '$_tmp_apk' && chmod 0644 '$_tmp_apk'"
    if su -c "pm install -r --user 0 '$_tmp_apk'"; then
      su -c "rm -f '$_tmp_apk'"
      return 0
    else
      err "pm install failed for $_apk"
      su -c "rm -f '$_tmp_apk'" || true
      return 1
    fi
  else
    return 1
  fi
}

task_apk_download_and_install() {
  log "Starting APK task..."
  mkdir -p "$APK_DIR"
  local _ok=0 _fail=0
  for url in "${APK_URLS[@]}"; do
    local name="${url##*/}"
    local out="${APK_DIR}/${name}"
    log "Downloading: $url"
    if http_fetch_to "$url" "$out"; then
      log "Installing: $name"
      if install_apk_file "$out"; then
        log "Installed: $name (deleting APK)"
        rm -f "$out" || true
        _ok=$((_ok+1))
      else
        err "Install failed: $name (keeping file for inspection)"
        _fail=$((_fail+1))
      fi
    else
      err "Download failed: $url"
      _fail=$((_fail+1))
    fi
  done
  log "APK task finished. Success: ${_ok}, Failed: ${_fail}"
  # Always remove any leftover APKs after attempts, per requirement
  find "$APK_DIR" -type f -name "*.apk" -print -delete 2>/dev/null || true
}

# ---------------- JSON handling ----------------
task_json_replace() {
  log "Starting JSON task..."
  ensure_storage_ready
  mkdir -p "$JSON_DEST_DIR"
  local tmp_json="${TMP_DIR}/SpeedHubX.Config.json"
  if http_fetch_to "$JSON_SRC_URL" "$tmp_json"; then
    # Backup existing file if present
    if [ -f "$JSON_DEST_FILE" ]; then
      local backup="${JSON_DEST_FILE}.bak.$(date -u +'%Y%m%dT%H%M%SZ')"
      cp -f "$JSON_DEST_FILE" "$backup" || true
      log "Backed up existing JSON to: $backup"
    fi
    # Replace contents atomically
    if mv -f "$tmp_json" "$JSON_DEST_FILE"; then
      log "Replaced JSON contents at: $JSON_DEST_FILE"
    else
      err "Failed to move JSON into place."
      return 1
    fi
  else
    err "Failed to download JSON: $JSON_SRC_URL"
    return 1
  fi
  return 0
}

# ---------------- Other Related ----------------
task_reconnect_foreground() {
  # Ensure directory exists (you provided lowercase 'download' — create it)
  if [ ! -d "/sdcard/download" ]; then
    mkdir -p "/sdcard/download" || true
  fi
  log "Fetching reconnect.lua..."
  if ! http_fetch_to "$RECONNECT_URL" "$RECONNECT_PATH"; then
    err "Failed to download reconnect.lua"
    # Ensure we still return non-zero from this task
    return 101
  fi
  # Run in foreground; never return exit code 0
  log "Running reconnect.lua in foreground..."
  lua "$RECONNECT_PATH"
  local rc=$?
  if [ $rc -eq 0 ]; then
    rc=111  # Force non-zero per requirement
  fi
  log "reconnect.lua exit code: $rc (forced non-zero if needed)"
  return $rc
}

# ---------------- First-run logic ----------------
run_first_time() {
  log "First run: executing all tasks once."
  task_apk_download_and_install || true
  task_json_replace || true
  task_reconnect_foreground || true
  touch "$FIRST_RUN_FLAG"
  # Initialize trigger sigs to current values so next loop only reacts to new workflow runs
  read_remote_sig "$TRIGGER_APK_URL" > "$LAST_APK_SIG_FILE" 2>/dev/null || true
  read_remote_sig "$TRIGGER_JSON_URL" > "$LAST_JSON_SIG_FILE" 2>/dev/null || true
  log "First run done."
}

# ---------------- Main loop ----------------
log "Runner started (foreground)."
need_cmd curl || exit 1
need_cmd sha256sum || exit 1

if [ ! -f "$FIRST_RUN_FLAG" ]; then
  run_first_time
fi

# Main foreground loop; pauses for triggers; no backgrounding
while :; do
  # Check triggers
  local_apk_state="$(trigger_changed "$TRIGGER_APK_URL" "$LAST_APK_SIG_FILE" | tail -n1 || echo "same")"
  local_json_state="$(trigger_changed "$TRIGGER_JSON_URL" "$LAST_JSON_SIG_FILE" | tail -n1 || echo "same")"

  busy=0
  if [ "$local_apk_state" != "same" ]; then
    busy=1
    log "APK trigger detected (${local_apk_state}). Pausing other tasks and processing APKs..."
    task_apk_download_and_install || true
    log "APK trigger completed."
  fi
  if [ "$local_json_state" != "same" ]; then
    busy=1
    log "JSON trigger detected (${local_json_state}). Pausing other tasks and processing JSON..."
    task_json_replace || true
    log "JSON trigger completed."
  fi

  # If triggers ran, skip reconnect in this cycle per "stop working until ... done"
  if [ $busy -eq 0 ]; then
    # Foreground; ensure non-zero from reconnect.lua; do not daemonize
    task_reconnect_foreground || true
  else
    log "Skipped reconnect.lua this cycle because a trigger ran."
  fi

  log "Sleeping for ${POLL_INTERVAL_SEC}s..."
  sleep "$POLL_INTERVAL_SEC"
done
