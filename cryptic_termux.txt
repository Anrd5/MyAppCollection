#!/usr/bin/env bash
# cryptic_daemon_orchestrated.sh
# Reconnect runs in the foreground (interactive).
# A background watcher pauses Reconnect during work, then restarts it.

set -u

# ----------------- Basic config -----------------
WORKDIR="${WORKDIR:-$HOME/cryptic_apks}"
POLL_INTERVAL="${POLL_INTERVAL:-30}"  # seconds

# Trigger files (expect '0' or '1')
TRIGGER_URL="${TRIGGER_URL:-https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshClones.txt}"
SCRIPT_TRIGGER_URL="${SCRIPT_TRIGGER_URL:-https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshScript.txt}"

# APK list
LINKS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# Config update
JSON_SOURCE_URL="${JSON_SOURCE_URL:-https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json}"
JSON_DEST="${JSON_DEST:-/storage/emulated/0/cryptic/Workspace/SpeedHubX/Grow a Garden.json}"

# Reconnect (interactive)
RECONNECT_URL="${RECONNECT_URL:-http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT3juUiLhzmuVwX321098d1fgg}"
RECONNECT_LUA="${RECONNECT_LUA:-/sdcard/download/reconnect.lua}"
RECON_PIDFILE="${WORKDIR}/reconnect.pid"

# State and queue
STATE_FILE_CLONES="${WORKDIR}/.last_refresh_clones"
STATE_FILE_SCRIPT="${WORKDIR}/.last_refresh_script"
PENDING_CLONES="${WORKDIR}/.pending_clones"
PENDING_SCRIPT="${WORKDIR}/.pending_script"
BUSY_LOCK="${WORKDIR}/.busy"
WATCHER_PIDFILE="${WORKDIR}/watcher.pid"

mkdir -p "$WORKDIR"

log() {
  printf '[%s] %s\n' "$(date '+%Y-%m-%dT%H:%M:%S%z')" "$*"
}

ensure_storage() {
  if [ ! -d "/sdcard" ] || [ ! -d "/sdcard/download" ]; then
    command -v termux-setup-storage >/dev/null 2>&1 && termux-setup-storage >/dev/null 2>&1 || true
    mkdir -p /sdcard/download 2>/dev/null || true
  fi
}

# ----------------- Downloader -----------------
DL_TOOL=""
if command -v curl >/dev/null 2>&1; then
  DL_TOOL="curl"
elif command -v wget >/dev/null 2>&1; then
  DL_TOOL="wget"
else
  command -v pkg >/dev/null 2>&1 && pkg update -y >/dev/null 2>&1 || true
  command -v pkg >/dev/null 2>&1 && pkg install -y curl >/dev/null 2>&1 || true
  if command -v curl >/dev/null 2>&1; then
    DL_TOOL="curl"
  elif command -v wget >/dev/null 2>&1; then
    DL_TOOL="wget"
  else
    log "No curl/wget available. Install one and re-run."
    exit 1
  fi
fi
log "Downloader: $DL_TOOL"

download_file() {
  local url="$1" out="$2"
  if [ "$DL_TOOL" = "curl" ]; then
    curl -L -C - -o "$out" "$url"
  else
    wget -c -O "$out" "$url"
  fi
}

get_remote_flag() {
  local url="$1" content=""
  if [ "$DL_TOOL" = "curl" ]; then
    content="$(curl -fsSL "$url" 2>/dev/null || true)"
  else
    content="$(wget -qO- "$url" 2>/dev/null || true)"
  fi
  content="$(printf '%s' "$content" | tr -d ' \t\r\n' | cut -c1 || true)"
  case "$content" in
    0|1) printf '%s' "$content" ;;
    *) printf '' ;;
  esac
}

# ----------------- Root + installs -----------------
ROOT_CMD=""
if command -v tsu >/dev/null 2>&1; then
  ROOT_CMD="tsu --"
elif command -v su >/dev/null 2>&1; then
  ROOT_CMD="su -c"
else
  log "No root found (tsu/su). Silent pm installs require root."
  log "Install tsu (pkg install tsu) or ensure su is available."
fi

install_apk_root() {
  local apk="$1"
  if [ -z "$ROOT_CMD" ]; then
    log "Skipping install (no root): $apk"
    return 1
  fi
  if command -v tsu >/dev/null 2>&1; then
    tsu pm install -r -g "$apk"
  else
    su -c "pm install -r -g '$apk'"
  fi
}

do_downloads_and_installs() {
  log "Starting APK batch ..."
  for url in "${LINKS[@]}"; do
    local fname="${url##*/}"
    log "Downloading: $fname"
    download_file "$url" "$WORKDIR/$fname" || { log "Download failed: $fname"; continue; }
    if [ ! -s "$WORKDIR/$fname" ]; then
      log "Empty file, skipping: $fname"
      continue
    fi
    log "Installing: $fname"
    install_apk_root "$WORKDIR/$fname" && log "Installed: $fname" || log "Install failed: $fname"
  done
  log "APK batch complete."
}

update_json_from_remote() {
  log "Updating JSON -> $JSON_DEST"
  local tmp="$WORKDIR/SpeedHubX.Config.json.tmp"
  download_file "$JSON_SOURCE_URL" "$tmp" || { log "JSON download failed"; return 1; }
  if [ ! -s "$tmp" ]; then
    log "JSON is empty. Aborting."
    return 1
  fi
  local dest_dir; dest_dir="$(dirname "$JSON_DEST")"
  if [ -n "$ROOT_CMD" ]; then
    if command -v tsu >/dev/null 2>&1; then
      tsu -- sh -c "mkdir -p '$dest_dir' && cp -f '$tmp' '$JSON_DEST'"
    else
      su -c "mkdir -p '$dest_dir' && cp -f '$tmp' '$JSON_DEST'"
    fi
  else
    mkdir -p "$dest_dir" 2>/dev/null || true
    cp -f "$tmp" "$JSON_DEST" 2>/dev/null || { log "Copy failed (no root?)"; return 1; }
  fi
  log "JSON updated."
  rm -f "$tmp" 2>/dev/null || true
}

# ----------------- Reconnect (interactive, foreground) -----------------
ensure_lua() {
  command -v lua >/dev/null 2>&1 && return 0
  log "Lua not found. Attempting to install..."
  command -v pkg >/dev/null 2>&1 && pkg update -y >/dev/null 2>&1 || true
  command -v pkg >/dev/null 2>&1 && pkg install -y lua >/dev/null 2>&1 || true
  command -v lua >/dev/null 2>&1 || { log "Lua still missing. Cannot run reconnect interactively."; return 1; }
}

fetch_reconnect() {
  ensure_storage
  if command -v curl >/dev/null 2>&1; then
    curl -L -o "$RECONNECT_LUA" "$RECONNECT_URL"
  else
    wget -O "$RECONNECT_LUA" "$RECONNECT_URL"
  fi
  [ -s "$RECONNECT_LUA" ]
}

start_reconnect_foreground() {
  fetch_reconnect || { log "Reconnect script failed to download."; return 1; }
  echo
  echo "=== Reconnect launching (interactive) ==="
  echo "Script: $RECONNECT_LUA"
  echo "It will pause automatically when work starts, then relaunch."
  echo

  # Start in foreground, but record its pid so we can stop it on demand
  # Use $0/$1 trick to pass filenames safely.
  bash -c 'echo $$ > "$0"; exec lua "$1"' "$RECON_PIDFILE" "$RECONNECT_LUA"
}

stop_reconnect_if_running() {
  if [ -f "$RECON_PIDFILE" ]; then
    local pid; pid="$(cat "$RECON_PIDFILE" 2>/dev/null || true)"
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
      kill "$pid" 2>/dev/null || true
      # Wait briefly for clean exit
      for _ in 1 2 3; do sleep 0.3; kill -0 "$pid" 2>/dev/null || break; done
      kill -9 "$pid" 2>/dev/null || true
    fi
    rm -f "$RECON_PIDFILE" 2>/dev/null || true
  fi
}

# ----------------- Watcher (background) -----------------
run_watcher_bg() {
  local parent_pid="$1"
  local last_clones="" last_script=""
  [ -f "$STATE_FILE_CLONES" ] && last_clones="$(cat "$STATE_FILE_CLONES" 2>/dev/null || true)"
  [ -f "$STATE_FILE_SCRIPT" ] && last_script="$(cat "$STATE_FILE_SCRIPT" 2>/dev/null || true)"

  log "Watcher started. Poll interval: ${POLL_INTERVAL}s"
  log "Triggers: clones=$TRIGGER_URL (last='$last_clones'), script=$SCRIPT_TRIGGER_URL (last='$last_script')"

  while true; do
    local remote_clones remote_script
    remote_clones="$(get_remote_flag "$TRIGGER_URL")"
    remote_script="$(get_remote_flag "$SCRIPT_TRIGGER_URL")"

    # Track 0 changes too, so we don't miss the next 1
    if [ -n "$remote_clones" ] && [ "$remote_clones" != "$last_clones" ]; then
      printf '%s' "$remote_clones" > "$STATE_FILE_CLONES"; last_clones="$remote_clones"
      if [ "$remote_clones" = "1" ] && [ ! -f "$BUSY_LOCK" ] && [ ! -f "$PENDING_CLONES" ]; then
        : > "$PENDING_CLONES"
        kill -USR1 "$parent_pid" 2>/dev/null || true
      fi
    fi

    if [ -n "$remote_script" ] && [ "$remote_script" != "$last_script" ]; then
      printf '%s' "$remote_script" > "$STATE_FILE_SCRIPT"; last_script="$remote_script"
      if [ "$remote_script" = "1" ] && [ ! -f "$BUSY_LOCK" ] && [ ! -f "$PENDING_SCRIPT" ]; then
        : > "$PENDING_SCRIPT"
        kill -USR1 "$parent_pid" 2>/dev/null || true
      fi
    fi

    sleep "$POLL_INTERVAL"
  done
}

start_watcher_bg() {
  if [ -f "$WATCHER_PIDFILE" ]; then
    local old; old="$(cat "$WATCHER_PIDFILE" 2>/dev/null || true)"
    if [ -n "$old" ] && kill -0 "$old" 2>/dev/null; then
      log "Watcher already running (PID $old)."
      return 0
    fi
  fi
  ( run_watcher_bg "$$" ) &
  echo $! > "$WATCHER_PIDFILE"
  log "Watcher PID $(cat "$WATCHER_PIDFILE")."
}

stop_watcher_bg() {
  [ -f "$WATCHER_PIDFILE" ] || return 0
  local pid; pid="$(cat "$WATCHER_PIDFILE" 2>/dev/null || true)"
  [ -n "$pid" ] && kill "$pid" 2>/dev/null || true
  rm -f "$WATCHER_PIDFILE" 2>/dev/null || true
}

# ----------------- Orchestration -----------------
NEED_WORK=0
on_usr1() {
  NEED_WORK=1
  # Stop Reconnect immediately; the main loop will perform queued work
  stop_reconnect_if_running
}
trap on_usr1 USR1
trap 'stop_reconnect_if_running; stop_watcher_bg; exit 0' INT TERM

process_pending_work() {
  [ -f "$PENDING_CLONES" ] || [ -f "$PENDING_SCRIPT" ] || return 0
  : > "$BUSY_LOCK"

  if [ -f "$PENDING_CLONES" ]; then
    rm -f "$PENDING_CLONES"
    do_downloads_and_installs
  fi

  if [ -f "$PENDING_SCRIPT" ]; then
    rm -f "$PENDING_SCRIPT"
    update_json_from_remote
  fi

  rm -f "$BUSY_LOCK" 2>/dev/null || true
}

# ----------------- Main -----------------
ensure_storage
ensure_lua || true
start_watcher_bg

# Optional: handle any queued work before first Reconnect launch
sleep 1
process_pending_work

# Main control loop:
# - Launch Reconnect in foreground (interactive).
# - If a trigger fires, watcher sends USR1; handler stops Reconnect.
# - Perform pending work, then loop to relaunch Reconnect.
while true; do
  NEED_WORK=0
  start_reconnect_foreground || true
  # When Reconnect exits (user closed it or we stopped it), handle work if needed
  process_pending_work
  # If user closed Reconnect manually and there's no work, relaunch it anyway
  # so it's available while idle.
done
