#!/data/data/com.termux/files/usr/bin/env bash
# SpeedHubX Termux Automation – Release-asset change detection with progress UI
# v1.2 — Adds progress bars and spinner for friendlier UX
set -Eeuo pipefail
IFS=$'\n\t'

#############################
# Configuration
#############################
APK_URLS=(
 "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
 "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
 "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
 "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
 "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
 "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
 "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
 "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
 "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/File.Manager.+.v3.6.1.Premium.apk"
)
JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"
DEST_JSON="/storage/emulated/0/Cryptic/Workspace/SpeedHubX/Grow a Garden.json"
SPEEDHUBX_INTERVAL="${SPEEDHUBX_INTERVAL:-1800}" # 30 minutes default
BOOT_FETCH_URL="${SPEEDHUBX_SCRIPT_URL:-}"

#############################
# Paths and state
#############################
PREFIX_DIR="${PREFIX:-/data/data/com.termux/files/usr}"
HOME_DIR="${HOME:-/data/data/com.termux/files/home}"
STATE_DIR="$PREFIX_DIR/var/lib/speedhubx"
WORK_DIR="$PREFIX_DIR/var/tmp/speedhubx"
LOG_DIR="$PREFIX_DIR/var/log"
LOG_FILE="$LOG_DIR/speedhubx.log"
BOOT_DIR="$HOME_DIR/.termux/boot"
LOCK_DIR="$STATE_DIR/.lock"

mkdir -p "$STATE_DIR" "$WORK_DIR" "$LOG_DIR"

FIRST_RUN_FLAG="$STATE_DIR/first_run.done"
BOOT_INSTALLED_FLAG="$STATE_DIR/boot_installed.flag"

# Map for pre-downloaded files when computing sha fallback
declare -gA PRE_DL_FILES=()

#############################
# Colors & logging
#############################
COLOR_RESET="\033[0m"
COLOR_INFO="\033[1;34m"   # bold blue
COLOR_OK="\033[1;32m"     # bold green
COLOR_WARN="\033[1;33m"   # bold yellow
COLOR_ERR="\033[1;31m"    # bold red

log() {
  local ts
  ts="$(date '+%Y-%m-%d %H:%M:%S')"
  printf "[%s] %s\n" "$ts" "$*" | tee -a "$LOG_FILE"
}

echo_info() { printf "%b%s%b\n" "$COLOR_INFO" "$*" "$COLOR_RESET"; log "$*"; }
echo_ok()   { printf "%b%s%b\n" "$COLOR_OK" "$*" "$COLOR_RESET"; log "$*"; }
echo_warn() { printf "%b%s%b\n" "$COLOR_WARN" "$*" "$COLOR_RESET"; log "$*"; }
echo_err()  { printf "%b%s%b\n" "$COLOR_ERR" "$*" "$COLOR_RESET"; log "$*"; }

on_error() {
  echo_err "ERROR: Line $1 exited with status $2"
}
trap 'on_error "$LINENO" "$?"' ERR

#############################
# Utilities
#############################
require_cmd() {
  command -v "$1" >/dev/null 2>&1 || {
    echo_warn "Command '$1' missing. Attempting to install via pkg..."
    yes | pkg install -y "$1" >/dev/null 2>&1 || true
    command -v "$1" >/dev/null 2>&1 || { echo_err "Fatal: missing command '$1'"; exit 1; }
  }
}

ensure_basics() {
  require_cmd curl
  # prefer sha256sum
  if ! command -v sha256sum >/dev/null 2>&1 && ! command -v shasum >/dev/null 2>&1 && ! command -v openssl >/dev/null 2>&1; then
    require_cmd coreutils || true
  fi
  # pm/su might not be present on non-android hosts, that's OK
  termux-setup-storage >/dev/null 2>&1 || true
}

acquire_lock() {
  if mkdir "$LOCK_DIR" 2>/dev/null; then
    trap 'rm -rf "$LOCK_DIR"' EXIT
  else
    echo_warn "Another instance appears to be running. Exiting."
    exit 0
  fi
}

# Spinner for quick operations (background)
spinner_start() {
  # $1 = message
  local msg=$1
  printf "%s " "$msg"
  # start spinner in background
  (
    local i=0
    local sp='|/-\'
    while :; do
      printf "\b%c" "${sp:i++%${#sp}:1}"
      sleep 0.12
    done
  ) &
  SPINNER_PID=$!
  disown "$SPINNER_PID" 2>/dev/null || true
}

spinner_stop() {
  local code=${1:-0}
  if [[ -n "${SPINNER_PID:-}" ]]; then
    kill "$SPINNER_PID" >/dev/null 2>&1 || true
    wait "$SPINNER_PID" 2>/dev/null || true
    unset SPINNER_PID
    if [[ "$code" -eq 0 ]]; then
      printf "\b" && echo_ok " done."
    else
      printf "\b" && echo_err " failed."
    fi
  fi
}

# Download with curl progress bar to target path (atomic move)
download_with_progress() {
  # $1 = url, $2 = out_path
  local url="$1" out="$2" tmp
  tmp="$(mktemp -p "$WORK_DIR" "$(basename "$out").tmp.XXXXXX")"
  echo_info "Downloading: $url"
  if curl -fL --retry 5 --retry-delay 2 --connect-timeout 15 --max-time 3600 \
      -A "SpeedHubX/1.2 (Termux)" --progress-bar -o "$tmp" "$url"; then
    mv -f "$tmp" "$out"
    echo_ok "Saved to: $out"
    return 0
  else
    rm -f -- "$tmp" || true
    echo_err "Download failed: $url"
    return 1
  fi
}

# Compute sha256 of file (portable)
file_sha256() {
  local f="$1"
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$f" | awk '{print $1}'
  elif command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$f" | awk '{print $1}'
  elif command -v openssl >/dev/null 2>&1; then
    openssl dgst -sha256 "$f" | awk '{print $2}'
  else
    # fallback using python if available
    if command -v python >/dev/null 2>&1; then
      python - <<PY -c "import sys,hashlib; h=hashlib.sha256(); h.update(sys.stdin.buffer.read()); print(h.hexdigest())" < "$f"
    else
      echo ""
    fi
  fi
}

# Hash a string deterministically (used for state filenames)
hash_string() {
  local s="$1"
  if command -v sha256sum >/dev/null 2>&1; then
    printf "%s" "$s" | sha256sum | awk '{print $1}'
  elif command -v shasum >/dev/null 2>&1; then
    printf "%s" "$s" | shasum -a 256 | awk '{print $1}'
  elif command -v openssl >/dev/null 2>&1; then
    printf "%s" "$s" | openssl dgst -sha256 | awk '{print $2}'
  else
    printf "%s" "$s" | md5sum | awk '{print $1}'
  fi
}

state_file_for_url() {
  local url="$1"
  local urlhash
  urlhash="$(hash_string "$url")"
  urlhash="${urlhash:0:16}"
  printf "%s/remote_%s.id" "$STATE_DIR" "$urlhash"
}

# Try to extract ETag or Last-Modified, else download to temp with progress and compute sha.
# Returns string like "etag:<value>", "lm:<value>", or "sha256:<hex>"
# For the sha256 fallback it will download to a temporary file and populate PRE_DL_FILES[url]=tmpfile
fetch_remote_id() {
  local url="$1"
  local headers etag lm tmp sha

  # perform HEAD-ish request (curl -I follows redirects)
  spinner_start "Checking headers for $(basename "$url")"
  headers="$(curl -sI -L --max-time 30 -A "SpeedHubX/1.2" "$url" 2>/dev/null || true)"
  spinner_stop 0

  etag="$(printf "%s" "$headers" | awk 'BEGIN{IGNORECASE=1} /ETag:/ {gsub(/^[ \t]+|[ \t]+$/,"",$0); sub(/ETag:[ \t]*/,"",$0); print $0; exit}')"
  if [[ -n "${etag:-}" ]]; then
    printf "etag:%s" "$etag"
    return 0
  fi

  lm="$(printf "%s" "$headers" | awk 'BEGIN{IGNORECASE=1} /Last-Modified:/ {gsub(/^[ \t]+|[ \t]+$/,"",$0); sub(/Last-Modified:[ \t]*/,"",$0); print $0; exit}')"
  if [[ -n "${lm:-}" ]]; then
    printf "lm:%s" "$lm"
    return 0
  fi

  # Fallback: download to temp with progress and sha
  echo_warn "No ETag/Last-Modified for $(basename "$url"); will download to compute sha256 (progress shown)."
  tmp="$(mktemp -p "$WORK_DIR" "$(basename "$url").prefetch.XXXXXX")"
  if download_with_progress "$url" "$tmp"; then
    sha="$(file_sha256 "$tmp")"
    if [[ -n "$sha" ]]; then
      PRE_DL_FILES["$url"]="$tmp"
      printf "sha256:%s" "$sha"
      return 0
    else
      rm -f -- "$tmp" || true
      return 1
    fi
  else
    rm -f -- "$tmp" || true
    return 1
  fi
}

# Handler: silent install an APK path (if predownloaded path provided re-use it)
silent_pm_install() {
  local apk="$1"
  if command -v su >/dev/null 2>&1; then
    su -c "pm install -r --user 0 \"$apk\"" >/dev/null 2>&1 || \
      su -c "pm install -r \"$apk\"" >/dev/null 2>&1 || \
      pm install -r "$apk"
  else
    pm install -r "$apk"
  fi
}

apk_handler() {
  # $1=url, $2=name, optional $3=predownloaded-file
  local url="$1" name="$2" pre="$3"
  local apkdir out tmp

  apkdir="$WORK_DIR/apks"
  mkdir -p "$apkdir"
  out="$apkdir/$name"

  if [[ -n "${pre:-}" && -f "$pre" ]]; then
    echo_info "Using predownload for $name"
    mv -f "$pre" "$out"
    unset PRE_DL_FILES["$url"]
  else
    # download with progress
    tmp="$out.tmp"
    if ! download_with_progress "$url" "$tmp"; then
      echo_err "Failed to download $name"
      return 1
    fi
    mv -f "$tmp" "$out"
  fi

  echo_info "Installing $name (silent if permitted)..."
  if silent_pm_install "$out"; then
    echo_ok "Install success: $name"
  else
    echo_warn "Install command returned non-zero for $name (may require manual approval)"
  fi

  # cleanup apk after install to save storage; keep for debugging if you prefer
  rm -f -- "$out" || true
}

json_handler() {
  # $1=url, $2=name, optional $3=predownloaded-file
  local url="$1" name="$2" pre="$3"
  local tmp

  if [[ -n "${pre:-}" && -f "$pre" ]]; then
    tmp="$pre"
    echo_info "Using predownload for JSON: $name"
  else
    tmp="$(mktemp -p "$WORK_DIR" "speedhubx.json.tmp.XXXXXX")"
    if ! download_with_progress "$url" "$tmp"; then
      echo_err "Failed to download JSON: $name"
      rm -f -- "$tmp" || true
      return 1
    fi
  fi

  mkdir -p "$(dirname "$DEST_JSON")"
  install -m 600 "$tmp" "$DEST_JSON"
  echo_ok "JSON written to: $DEST_JSON"

  # remove predownload or tmp
  if [[ -n "${PRE_DL_FILES[$url]:-}" && "${PRE_DL_FILES[$url]}" == "$tmp" ]]; then
    unset PRE_DL_FILES["$url"]
  else
    rm -f -- "$tmp" || true
  fi
}

check_and_run_url() {
  # $1 = url, $2 = name, $3 = handler function name
  local url="$1" name="$2" handler="$3"
  local statefile newid oldid prefile

  statefile="$(state_file_for_url "$url")"
  mkdir -p "$(dirname "$statefile")"

  echo_info "Checking remote for: $name"
  if ! newid="$(fetch_remote_id "$url" 2>/dev/null || true)"; then
    echo_warn "Could not determine remote id for $name ($url); skipping"
    return 0
  fi

  # If there is a predownloaded file from fetch_remote_id sha fallback, capture it
  prefile="${PRE_DL_FILES[$url]:-}"

  if [[ ! -s "$statefile" ]]; then
    echo_warn "$name: No prior state; treating as changed and running handler"
    echo "$newid" >"$statefile".tmp && mv "$statefile".tmp "$statefile"
    "$handler" "$url" "$name" "$prefile"
    return 0
  fi

  oldid="$(cat "$statefile" 2>/dev/null || true)"
  if [[ "$newid" != "$oldid" ]]; then
    echo_info "$name: Change detected (old != new). Running handler..."
    echo "$newid" >"$statefile".tmp && mv "$statefile".tmp "$statefile"
    "$handler" "$url" "$name" "$prefile"
  else
    echo_ok "$name: No change."
    # cleanup any predownloaded file we won't use
    if [[ -n "$prefile" && -f "$prefile" ]]; then
      rm -f -- "$prefile" || true
      unset PRE_DL_FILES["$url"]
    fi
  fi
}

run_apk_tasks() {
  echo_info "APK: Checking configured APK URLs..."
  for url in "${APK_URLS[@]}"; do
    local name
    name="$(basename "$url")"
    check_and_run_url "$url" "$name" apk_handler
  done
  echo_info "APK checks done."
}

run_json_tasks() {
  echo_info "JSON: Checking JSON URL..."
  check_and_run_url "$JSON_URL" "SpeedHubX.Config.json" json_handler
}

install_termux_boot() {
  mkdir -p "$BOOT_DIR"
  if [[ -n "$BOOT_FETCH_URL" ]]; then
    cat >"$BOOT_DIR/99-speedhubx.sh" <<EOF
#!/data/data/com.termux/files/usr/bin/env bash
set -Eeuo pipefail
export SPEEDHUBX_INTERVAL="${SPEEDHUBX_INTERVAL}"
curl -fL --retry 5 --connect-timeout 15 --max-time 120 \
  -A "SpeedHubX/1.2 (TermuxBoot)" \
  "$BOOT_FETCH_URL" | bash -s -- --boot
EOF
    chmod +x "$BOOT_DIR/99-speedhubx.sh"
    echo_ok "Installed Termux:Boot fetch-run launcher"
  else
    if [[ -f "$0" && -r "$0" ]]; then
      cp -f "$0" "$BOOT_DIR/99-speedhubx.sh"
      chmod +x "$BOOT_DIR/99-speedhubx.sh"
      echo_ok "Installed this script into Termux:Boot"
    else
      cat >"$BOOT_DIR/99-speedhubx.sh" <<'EOSH'
#!/data/data/com.termux/files/usr/bin/env bash
set -Eeuo pipefail
STATE_DIR="${PREFIX:-/data/data/com.termux/files/usr}/var/lib/speedhubx"
WORKER="$STATE_DIR/worker.sh"
if [[ -x "$WORKER" ]]; then
  bash "$WORKER" --boot
fi
EOSH
      chmod +x "$BOOT_DIR/99-speedhubx.sh"
      mkdir -p "$STATE_DIR"
      if [[ -f "$0" ]]; then
        cp -f "$0" "$STATE_DIR/worker.sh"
        chmod +x "$STATE_DIR/worker.sh"
      fi
      echo_ok "Installed bootstrap into Termux:Boot (no URL provided)"
    fi
  fi
  touch "$BOOT_INSTALLED_FLAG"
}

first_run_init() {
  if [[ ! -f "$FIRST_RUN_FLAG" ]]; then
    echo_info "First execution: performing initial fetch/install (will treat resources as changed)."
    run_apk_tasks
    run_json_tasks
    touch "$FIRST_RUN_FLAG"
  fi
}

continuous_loop() {
  echo_info "Entering continuous mode; polling every ${SPEEDHUBX_INTERVAL}s"
  while true; do
    run_apk_tasks
    run_json_tasks
    sleep "$SPEEDHUBX_INTERVAL"
  done
}

main() {
  acquire_lock
  ensure_basics

  if [[ ! -f "$BOOT_INSTALLED_FLAG" ]]; then
    install_termux_boot
  fi

  first_run_init
  continuous_loop
}

case "${1:-}" in
  --boot)
    shift
    main
    ;;
  --once)
    acquire_lock
    ensure_basics
    run_apk_tasks
    run_json_tasks
    ;;
  --help|-h)
    cat <<EOF
Usage: speedhubx.sh [--boot | --once]
  --boot    Run in boot/continuous mode (default)
  --once    Run a single-check cycle and exit
EOF
    ;;
  *)
    main
    ;;
esac
