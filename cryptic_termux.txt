#!/usr/bin/env bash
# install_cryptics_daemon.sh
# APK installer + JSON replacer + daemon with dual triggers and reconnect control
# Behavior:
# - On 0->1 trigger, stop reconnect completely.
# - Primary pass: try standard download/install for all items, collect failures.
# - Retry pass: try alternate download/install methods for failures.
# - Start reconnect in the foreground (daemon waits until it exits).
# Notes:
# - Foreground reconnect ensures no background interference.
# - Robust fallbacks for downloader and installer.
# - Daemonize/logging/test modes are supported.

set -u

# ----------------- Configuration (override via env) -----------------
WORKDIR="${WORKDIR:-$HOME/cryptic_apks}"
KEEP_APKS="${KEEP_APKS:-0}"
POLL_INTERVAL="${POLL_INTERVAL:-30}"

# Triggers (0/1 text, read first char after trimming)
TRIGGER_CLONES_URL="${TRIGGER_CLONES_URL:-https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshClones.txt}"
TRIGGER_SCRIPT_URL="${TRIGGER_SCRIPT_URL:-https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshScript.txt}"

# State files
STATE_CLONES_FILE="${WORKDIR}/.last_refresh_clones"
STATE_SCRIPT_FILE="${WORKDIR}/.last_refresh_script"

# Logging / PID
PIDFILE_DEFAULT="${WORKDIR}/cryptic_daemon.pid"
LOGFILE_DEFAULT="${HOME}/cryptic_daemon.log"

# JSON replacement
SPEEDHUBX_DIR="${SPEEDHUBX_DIR:-/storage/emulated/0/Cryptic/Workspace/SpeedHubX}"
SPEEDHUBX_TARGET_JSON="${SPEEDHUBX_TARGET_JSON:-Grow a Garden.json}"
SPEEDHUBX_CONFIG_URL="${SPEEDHUBX_CONFIG_URL:-https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json}"

# Reconnect controller (foreground run)
RECONNECT_LUA_URL="${RECONNECT_LUA_URL:-http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg}"
RECONNECT_LUA_PATH="${RECONNECT_LUA_PATH:-/sdcard/download/reconnect.lua}"

# APK links
LINKS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# ----------------- CLI parsing -----------------
DAEMONIZE=0
TEST_MODE=0
PIDFILE=""
LOGFILE=""

usage() {
  cat <<EOF
Usage: $0 [OPTIONS]

Options:
  --daemonize           Run as background daemon (nohup), writes PID & log
  --pidfile <path>      PID file (default: ${PIDFILE_DEFAULT})
  --logfile <path>      Log file (default: ${LOGFILE_DEFAULT})
  --test                Test mode: only first APK once, then exit
  --help                Show this help and exit

Environment variables:
  WORKDIR, KEEP_APKS, POLL_INTERVAL
  TRIGGER_CLONES_URL, TRIGGER_SCRIPT_URL
  SPEEDHUBX_DIR, SPEEDHUBX_TARGET_JSON, SPEEDHUBX_CONFIG_URL
  RECONNECT_LUA_URL, RECONNECT_LUA_PATH
EOF
}

i=1
while [ $i -le $# ]; do
  arg="${!i}"
  case "$arg" in
    --daemonize) DAEMONIZE=1 ;;
    --pidfile) i=$((i+1)); PIDFILE="${!i:-}" ;;
    --logfile) i=$((i+1)); LOGFILE="${!i:-}" ;;
    --test) TEST_MODE=1 ;;
    --help|-h) usage; exit 0 ;;
    *) echo "Unknown option: $arg"; usage; exit 1 ;;
  esac
  i=$((i+1))
done

PIDFILE="${PIDFILE:-$PIDFILE_DEFAULT}"
LOGFILE="${LOGFILE:-$LOGFILE_DEFAULT}"

# ----------------- Setup -----------------
mkdir -p "$WORKDIR"
cd "$WORKDIR" || { echo "ERROR: cannot cd to $WORKDIR"; exit 1; }

log() { printf '[%s] %s\n' "$(date --iso-8601=seconds 2>/dev/null || date '+%F %T')" "$*"; }

# Daemonize parent
if [ "$DAEMONIZE" = 1 ]; then
  if [ -f "$PIDFILE" ]; then
    oldpid="$(cat "$PIDFILE" 2>/dev/null || true)"
    if [ -n "$oldpid" ] && kill -0 "$oldpid" 2>/dev/null; then
      echo "Daemon already running (PID $oldpid). Exiting."
      exit 0
    else
      rm -f "$PIDFILE" 2>/dev/null || true
    fi
  fi
  mkdir -p "$(dirname "$LOGFILE")" 2>/dev/null || true
  nohup "$0" --pidfile "$PIDFILE" --logfile "$LOGFILE" > "$LOGFILE" 2>&1 &
  childpid=$!
  echo "$childpid" > "$PIDFILE"
  echo "Started daemon (PID $childpid). Log: $LOGFILE  PID: $PIDFILE"
  exit 0
fi

# Foreground process writes PID and cleans up
printf '%s' "$$" > "$PIDFILE" 2>/dev/null || true
trap 'if [ -f "$PIDFILE" ] && [ "$(cat "$PIDFILE" 2>/dev/null)" = "$$" ]; then rm -f "$PIDFILE"; fi; log "Exiting"; exit 0' SIGINT SIGTERM EXIT

# ----------------- Downloader selection and helpers -----------------
DL_PRIMARY=""
DL_ALT=""

ensure_downloader() {
  if command -v wget >/dev/null 2>&1; then
    DL_PRIMARY="wget"; DL_ALT="curl"
  elif command -v curl >/dev/null 2>&1; then
    DL_PRIMARY="curl"; DL_ALT="wget"
  else
    log "No wget/curl found. Attempting to install via pkg..."
    pkg update -y >/dev/null 2>&1 || true
    pkg install -y wget >/dev/null 2>&1 || true
    if command -v wget >/dev/null 2>&1; then
      DL_PRIMARY="wget"; DL_ALT="curl"
    else
      pkg install -y curl >/dev/null 2>&1 || true
      if command -v curl >/dev/null 2>&1; then
        DL_PRIMARY="curl"; DL_ALT="wget"
      else
        log "Failed to obtain wget/curl. Install one and re-run."
        exit 1
      fi
    fi
  fi
  log "Downloader chosen: $DL_PRIMARY (alt: $DL_ALT)"
}
ensure_downloader

download_with() {
  local tool="$1" url="$2" out="$3" pass="$4"
  if [ "$tool" = "wget" ]; then
    # pass 1: quiet resume; pass 2: extra retries + IPv4
    if [ "$passX$pass" = "X1" ]; then
      wget -q -c -O "$out" "$url"
    else
      wget -q -t 3 --timeout=20 --dns-timeout=10 -4 -c -O "$out" "$url"
    fi
  else
    # pass 1: standard; pass 2: retries + connect-timeout
    if [ "$passX$pass" = "X1" ]; then
      curl -L -C - -o "$out" "$url"
    else
      curl -L --retry 3 --retry-delay 2 --connect-timeout 20 -C - -o "$out" "$url"
    fi
  fi
}

download_to() {
  local url="$1" out="$2" pass="${3:-1}"
  # Try primary
  if ! download_with "$DL_PRIMARY" "$url" "$out" "$pass"; then
    log "Primary downloader failed for $url (pass $pass). Trying alt: $DL_ALT"
    if command -v "$DL_ALT" >/dev/null 2>&1; then
      if ! download_with "$DL_ALT" "$url" "$out" "$pass"; then
        log "Alt downloader also failed for $url (pass $pass)"
        return 1
      fi
    else
      log "Alternate downloader $DL_ALT not available."
      return 1
    fi
  fi
  [ -s "$out" ]
}

fetch_text_onechar() {
  local url="$1" content=""
  if [ "$DL_PRIMARY" = "wget" ]; then
    content="$(wget -qO- "$url" 2>/dev/null || true)"
    [ -z "$content" ] && command -v curl >/dev/null 2>&1 && content="$(curl -fsSL "$url" 2>/dev/null || true)"
  else
    content="$(curl -fsSL "$url" 2>/dev/null || true)"
    [ -z "$content" ] && command -v wget >/dev/null 2>&1 && content="$(wget -qO- "$url" 2>/dev/null || true)"
  fi
  content="$(printf '%s' "$content" | tr -d ' \t\r\n' | cut -c1 || true)"
  case "$content" in 0|1) printf '%s' "$content" ;; *) printf '' ;; esac
}

# ----------------- Root helper -----------------
ROOT_CMD=""
if command -v tsu >/dev/null 2>&1; then
  ROOT_CMD="tsu --"
elif command -v su >/dev/null 2>&1; then
  ROOT_CMD="su -c"
else
  log "No root helper (tsu or su) found. Script requires root to install silently."
  log "Install tsu (pkg install tsu) or ensure su is available, then re-run."
  exit 1
fi
log "Using root command: ${ROOT_CMD%% *}"

run_root() {
  if command -v tsu >/dev/null 2>&1; then
    tsu "$@"
  else
    su -c "$*"
  fi
}

# ----------------- APK installers (primary + alternate) -----------------
install_apk_primary() {
  local apk="$1"
  run_root "pm install -r -g '$apk'" && return 0
  run_root "pm install -r '$apk'" && return 0
  run_root "cmd package install -r -g '$apk'" && return 0
  run_root "cmd package install -r '$apk'" && return 0
  return 1
}

install_apk_alternate() {
  local apk="$1"
  # Try with explicit user 0 and installer hint
  run_root "pm install --user 0 -r -g '$apk'" && return 0
  run_root "pm install -i com.android.vending -r -g '$apk'" && return 0
  run_root "cmd package install --user 0 -r -g '$apk'" && return 0
  # As a last resort, re-try plain -r
  run_root "pm install -r '$apk'" && return 0
  return 1
}

# ----------------- Reconnect control (foreground run) -----------------
ensure_lua() {
  if command -v lua >/dev/null 2>&1; then return 0; fi
  log "lua not found. Attempting to install via pkg..."
  pkg update -y >/dev/null 2>&1 || true
  pkg install -y lua >/dev/null 2>&1 || true
  command -v lua >/dev/null 2>&1
}

pids_for_reconnect() {
  ps 2>/dev/null | grep -E "lua .*$RECONNECT_LUA_PATH|$RECONNECT_LUA_PATH" | grep -v grep | awk '{print $1}'
}

reconnect_stop() {
  local pids; pids="$(pids_for_reconnect || true)"
  if [ -n "$pids" ]; then
    log "Stopping reconnect (PIDs: $pids)..."
    for p in $pids; do kill "$p" 2>/dev/null || true; done
    sleep 1
    pids="$(pids_for_reconnect || true)"
    for p in $pids; do kill -9 "$p" 2>/dev/null || true; done
  else
    log "Reconnect not running."
  fi
}

reconnect_start_foreground() {
  mkdir -p "$(dirname "$RECONNECT_LUA_PATH")" 2>/dev/null || true
  log "Fetching reconnect.lua..."
  if ! download_to "$RECONNECT_LUA_URL" "$RECONNECT_LUA_PATH" 1; then
    log "Failed to download reconnect.lua (primary). Retrying with alternate..."
    if ! download_to "$RECONNECT_LUA_URL" "$RECONNECT_LUA_PATH" 2; then
      log "Failed to obtain reconnect.lua. Skipping start."
      return 1
    fi
  fi
  chmod 644 "$RECONNECT_LUA_PATH" 2>/dev/null || true
  if ! ensure_lua; then
    log "lua unavailable; cannot start reconnect."
    return 1
  fi
  log "Launching reconnect in foreground..."
  lua "$RECONNECT_LUA_PATH"
  # When reconnect exits, we return to daemon loop
}

# ----------------- Core tasks with two-phase retry -----------------
do_downloads_and_installs() {
  log "Starting APK downloads and installs (primary pass)..."

  # Collect failures
  FAILED_DL_URLS=()
  FAILED_INST_PATHS=()

  for url in "${LINKS[@]}"; do
    fname="${url##*/}"
    fpath="$WORKDIR/$fname"

    # Clean zero-size leftovers
    [ -f "$fpath" ] && [ ! -s "$fpath" ] && { log "Removing zero-size stale $fname"; rm -f "$fpath"; }

    # Primary download
    log "Downloading (primary): $url"
    if ! download_to "$url" "$fpath" 1; then
      log "Download failed (primary): $fname"
      FAILED_DL_URLS+=("$url")
      continue
    fi
    if [ ! -s "$fpath" ]; then
      log "Downloaded empty file: $fname"
      FAILED_DL_URLS+=("$url")
      continue
    fi

    # Primary install
    log "Installing (primary): $fname"
    if ! install_apk_primary "$fpath"; then
      log "Install failed (primary): $fname"
      FAILED_INST_PATHS+=("$fpath")
      continue
    fi

    # Success
    log "Installed: $fname"
    if [ "$KEEP_APKS" = "0" ]; then rm -f "$fpath"; else log "Keeping $fname (KEEP_APKS=1)"; fi
  done

  # Retry failed downloads with alternate methods
  if [ ${#FAILED_DL_URLS[@]} -gt 0 ]; then
    log "Retrying failed downloads (alternate methods)..."
    local retried=()
    for url in "${FAILED_DL_URLS[@]}"; do
      fname="${url##*/}"
      fpath="$WORKDIR/$fname"
      log "Retry download (alt): $url"
      if download_to "$url" "$fpath" 2 && [ -s "$fpath" ]; then
        log "Retry succeeded: $fname"
        retried+=("$fpath")
      else
        log "Retry failed: $fname"
      fi
    done
    # Attempt installs for any downloads that succeeded on retry
    for fpath in "${retried[@]}"; do
      fname="${fpath##*/}"
      log "Installing (after download retry): $fname"
      if install_apk_primary "$fpath" || install_apk_alternate "$fpath"; then
        log "Installed after retry: $fname"
        if [ "$KEEP_APKS" = "0" ]; then rm -f "$fpath"; fi
      else
        log "Install still failing after retry: $fname"
        FAILED_INST_PATHS+=("$fpath")
      fi
    done
  fi

  # Retry failed installs with alternate installer methods
  if [ ${#FAILED_INST_PATHS[@]} -gt 0 ]; then
    log "Retrying failed installs (alternate installer)..."
    for fpath in "${FAILED_INST_PATHS[@]}"; do
      [ -f "$fpath" ] || continue
      fname="${fpath##*/}"
      log "Retry install (alt): $fname"
      if install_apk_alternate "$fpath"; then
        log "Alt install succeeded: $fname"
        if [ "$KEEP_APKS" = "0" ]; then rm -f "$fpath"; fi
      else
        log "Alt install failed: $fname (kept for debugging)"
      fi
    done
  fi

  log "APK tasks finished."
}

replace_speedhubx_json() {
  local target_dir="$SPEEDHUBX_DIR"
  local target_json="$SPEEDHUBX_TARGET_JSON"
  local src_url="$SPEEDHUBX_CONFIG_URL"
  local tmp_file="$WORKDIR/.speedhubx_config.tmp"

  log "Replacing JSON: $target_dir/$target_json"
  mkdir -p "$target_dir" 2>/dev/null || true

  log "Downloading config (primary): $src_url"
  if ! download_to "$src_url" "$tmp_file" 1; then
    log "Config download failed (primary). Retrying (alternate)..."
    if ! download_to "$src_url" "$tmp_file" 2; then
      log "Config download failed after retry."
      return 1
    fi
  fi
  if [ ! -s "$tmp_file" ]; then
    log "Config file empty after download."
    rm -f "$tmp_file" 2>/dev/null || true
    return 1
  fi

  # Backup and replace atomically
  if [ -f "$target_dir/$target_json" ]; then
    cp -f "$target_dir/$target_json" "$target_dir/${target_json}.bak" 2>/dev/null || true
    log "Backed up to: ${target_json}.bak"
  fi
  if mv -f "$tmp_file" "$target_dir/$target_json"; then
    chmod 644 "$target_dir/$target_json" 2>/dev/null || true
    log "JSON replaced successfully."
    return 0
  else
    log "Failed to move new JSON into place."
    rm -f "$tmp_file" 2>/dev/null || true
    return 1
  fi
}

# ----------------- TEST mode -----------------
if [ "$TEST_MODE" = 1 ]; then
  log "TEST MODE: only downloading + installing the first APK once."
  if [ ${#LINKS[@]} -gt 0 ]; then LINKS=("${LINKS[0]}"); fi
  # Ensure reconnect not running during test to avoid conflicts
  reconnect_stop
  do_downloads_and_installs
  reconnect_start_foreground
  exit 0
fi

# ----------------- Daemon loop -----------------
last_clones=""
last_script=""

[ -f "$STATE_CLONES_FILE" ] && last_clones="$(cat "$STATE_CLONES_FILE" 2>/dev/null || true)"
[ -f "$STATE_SCRIPT_FILE" ] && last_script="$(cat "$STATE_SCRIPT_FILE" 2>/dev/null || true)"
last_clones="${last_clones:-}"
last_script="${last_script:-}"

log "Daemon starting."
log "Polling clones trigger: $TRIGGER_CLONES_URL"
log "Polling script trigger: $TRIGGER_SCRIPT_URL"
log "Every ${POLL_INTERVAL}s. Initial states: clones='${last_clones}' script='${last_script}'. Logfile: ${LOGFILE}"

while true; do
  remote_clones="$(fetch_text_onechar "$TRIGGER_CLONES_URL")"
  remote_script="$(fetch_text_onechar "$TRIGGER_SCRIPT_URL")"

  [ -z "$remote_clones" ] && log "Warning: could not fetch clones trigger."
  [ -z "$remote_script" ] && log "Warning: could not fetch script trigger."

  run_clones=0
  run_script=0

  if [ -n "$remote_clones" ] && [ "$remote_clones" != "$last_clones" ]; then
    log "Clones trigger changed: '$last_clones' -> '$remote_clones'"
    if [ "$remote_clones" = "1" ]; then run_clones=1; else log "Clones trigger is '0' — idle."; fi
    printf '%s' "$remote_clones" > "$STATE_CLONES_FILE"
    last_clones="$remote_clones"
  fi

  if [ -n "$remote_script" ] && [ "$remote_script" != "$last_script" ]; then
    log "Script trigger changed: '$last_script' -> '$remote_script'"
    if [ "$remote_script" = "1" ]; then run_script=1; else log "Script trigger is '0' — idle."; fi
    printf '%s' "$remote_script" > "$STATE_SCRIPT_FILE"
    last_script="$remote_script"
  fi

  if [ "$run_clones" = "1" ] || [ "$run_script" = "1" ]; then
    # Stop reconnect only during the triggered operation
    reconnect_stop

    [ "$run_clones" = "1" ] && do_downloads_and_installs
    [ "$run_script" = "1" ] && replace_speedhubx_json

    # Start reconnect in foreground (blocks until it exits)
    reconnect_start_foreground
  fi

  sleep "$POLL_INTERVAL"
done
