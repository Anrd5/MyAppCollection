#!/usr/bin/env bash
# minimal_controller.sh
set -Eeuo pipefail

# -------- Config --------
RECONNECT_URL="${RECONNECT_URL:-http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT3juUiLhzmuVwX321098d1fgg}"
RECONNECT_LUA="${RECONNECT_LUA:-/sdcard/download/reconnect.lua}"

TRIGGER_CLONES_URL="${TRIGGER_CLONES_URL:-https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshClones.txt}"
TRIGGER_SCRIPT_URL="${TRIGGER_SCRIPT_URL:-https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/RefreshScript.txt}"

# APK list to refresh on clones trigger
APK_LINKS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# JSON refresh on script trigger
JSON_SOURCE_URL="${JSON_SOURCE_URL:-https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json}"
JSON_DEST="${JSON_DEST:-/storage/emulated/0/cryptic/Workspace/SpeedHubX/Grow a Garden.json}"

POLL_INTERVAL="${POLL_INTERVAL:-30}"   # seconds
WORKDIR="${WORKDIR:-$HOME/.cryptic_controller}"
LOGFILE="$WORKDIR/watcher.log"
RECONNECT_PIDFILE="$WORKDIR/reconnect.pid"
STATE_CLONES="$WORKDIR/.state_clones"
STATE_SCRIPT="$WORKDIR/.state_script"
PENDING_CLONES="$WORKDIR/.pending_clones"
PENDING_SCRIPT="$WORKDIR/.pending_script"
BUSY_LOCK="$WORKDIR/.busy"
CTRL_PIDFILE="$WORKDIR/controller.pid"

mkdir -p "$WORKDIR"

# -------- Helpers --------
have() { command -v "$1" >/dev/null 2>&1; }
die() { echo "$*" >&2; exit 1; }

curl_get() { curl -fsSL "$1"; }
curl_to() { curl -fsSL -o "$2" "$1"; }

get_flag() {
  local s; s="$(curl_get "$1" 2>/dev/null || true)"
  printf '%s' "$s" | tr -d ' \t\r\n' | cut -c1
}

ensure_storage() {
  [ -d /sdcard ] || { have termux-setup-storage && termux-setup-storage >/dev/null 2>&1 || true; }
  mkdir -p "/sdcard/download" >/dev/null 2>&1 || true
}

install_apk_root() {
  local apk="$1"
  if have tsu; then tsu pm install -r -g "$apk"
  elif have su; then su -c "pm install -r -g '$apk'"
  else
    return 1
  fi
}

# -------- Watcher (silent) --------
watcher() {
  exec >>"$LOGFILE" 2>&1
  echo "[$(date +%F\ %T)] watcher start (poll=${POLL_INTERVAL}s)"
  local last_c="" last_s=""
  [ -f "$STATE_CLONES" ] && last_c="$(cat "$STATE_CLONES" 2>/dev/null || true)"
  [ -f "$STATE_SCRIPT" ] && last_s="$(cat "$STATE_SCRIPT" 2>/dev/null || true)"

  while :; do
    # Skip polling while busy to avoid racing
    if [ -f "$BUSY_LOCK" ]; then
      sleep "$POLL_INTERVAL"; continue
    fi

    local fc fs
    fc="$(get_flag "$TRIGGER_CLONES_URL")"
    fs="$(get_flag "$TRIGGER_SCRIPT_URL")"

    if [ -n "$fc" ] && [ "$fc" != "$last_c" ]; then
      printf '%s' "$fc" > "$STATE_CLONES"; last_c="$fc"
      if [ "$fc" = "1" ] && [ ! -f "$PENDING_CLONES" ]; then : > "$PENDING_CLONES"; fi
    fi
    if [ -n "$fs" ] && [ "$fs" != "$last_s" ]; then
      printf '%s' "$fs" > "$STATE_SCRIPT"; last_s="$fs"
      if [ "$fs" = "1" ] && [ ! -f "$PENDING_SCRIPT" ]; then : > "$PENDING_SCRIPT"; fi
    fi

    # If any work is pending, stop reconnect so controller can process
    if [ -f "$PENDING_CLONES" ] || [ -f "$PENDING_SCRIPT" ]; then
      if [ -f "$RECONNECT_PIDFILE" ]; then
        local pid; pid="$(cat "$RECONNECT_PIDFILE" 2>/dev/null || true)"
        if [ -n "${pid:-}" ] && kill -0 "$pid" 2>/dev/null; then
          echo "[$(date +%F\ %T)] stopping reconnect pid=$pid for update"
          kill "$pid" 2>/dev/null || true
          sleep 1
          kill -9 "$pid" 2>/dev/null || true
        fi
      fi
    fi

    sleep "$POLL_INTERVAL"
  done
}

# -------- Work steps (only when triggered) --------
do_clones_refresh() {
  echo "[update] Refreshing APK clones..."
  mkdir -p "$WORKDIR/apks"
  for url in "${APK_LINKS[@]}"; do
    f="$WORKDIR/apks/${url##*/}"
    echo "[update] download ${url##*/}"
    curl_to "$url" "$f" || { echo "[warn] failed ${url##*/}"; continue; }
    if ! install_apk_root "$f"; then
      echo "[note] skipped install (no root): ${url##*/}"
    fi
  done
  echo "[update] APK refresh done."
}

do_script_refresh() {
  echo "[update] Updating JSON config..."
  tmp="$WORKDIR/SpeedHubX.Config.json.tmp"
  curl_to "$JSON_SOURCE_URL" "$tmp" || { echo "[warn] failed JSON download"; return 0; }
  dest_dir="$(dirname "$JSON_DEST")"
  mkdir -p "$dest_dir" 2>/dev/null || true
  if have tsu; then tsu -- sh -c "cp -f '$tmp' '$JSON_DEST'"
  elif have su; then su -c "cp -f '$tmp' '$JSON_DEST'"
  else cp -f "$tmp" "$JSON_DEST" 2>/dev/null || echo "[warn] copy may require permissions"
  fi
  rm -f "$tmp"
  echo "[update] JSON updated -> $JSON_DEST"
}

process_pending() {
  : > "$BUSY_LOCK"
  if [ -f "$PENDING_CLONES" ]; then rm -f "$PENDING_CLONES"; do_clones_refresh; fi
  if [ -f "$PENDING_SCRIPT" ]; then rm -f "$PENDING_SCRIPT"; do_script_refresh; fi
  rm -f "$BUSY_LOCK"
}

# -------- Controller --------
# prevent duplicate instances
if [ -f "$CTRL_PIDFILE" ]; then
  old="$(cat "$CTRL_PIDFILE" 2>/dev/null || true)"
  if [ -n "${old:-}" ] && kill -0 "$old" 2>/dev/null; then
    echo "Already running (PID $old)."; exit 0
  fi
fi
echo "$$" > "$CTRL_PIDFILE"
trap 'rm -f "$CTRL_PIDFILE" "$RECONNECT_PIDFILE" "$BUSY_LOCK" >/dev/null 2>&1 || true' EXIT

ensure_storage
have curl || die "curl required."

# start watcher silently
(watcher) >/dev/null 2>&1 &

# main loop: keep Reconnect foreground unless a trigger arrives
while :; do
  # Fetch and run Reconnect (foreground). Write its pid so watcher can pause it.
  curl -fsSL -L -o "$RECONNECT_LUA" "$RECONNECT_URL" || true
  bash -c 'echo $$ > "$0"; exec lua "$1"' "$RECONNECT_PIDFILE" "$RECONNECT_LUA" || true

  # If we got here because watcher killed it, do pending work; otherwise user exited.
  if [ -f "$PENDING_CLONES" ] || [ -f "$PENDING_SCRIPT" ]; then
    process_pending
    # loop will resume Reconnect
  else
    # user likely exited Reconnect; loop to relaunch to keep it running
    :
  fi
done
