#!/usr/bin/env bash
# Cryptic Termux Installer + Daemon + Config Management
# Combines daemonized APK install flow with robust JSON configurment.

set -Eeuo pipefail
IFS=$'\n\t'

# ── Core defaults (override via env or flags) ────────────────────────────
APP_NAME="${APP_NAME:-Cryptic}"
WORKDIR="${WORKDIR:-$HOME/cryptic_apks}"
KEEP_APKS="${KEEP_APKS:-0}"               # 0=delete after success, 1=keep
POLL_INTERVAL="${POLL_INTERVAL:-30}"      # seconds
TRIGGER_URL="${TRIGGER_URL:-https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/RefreshClones.txt}"
STATE_FILE="${STATE_FILE:-$WORKDIR/.last_refresh_state}"
PIDFILE_DEFAULT="${PIDFILE_DEFAULT:-$WORKDIR/cryptic_daemon.pid}"
LOGFILE_DEFAULT="${LOGFILE_DEFAULT:-$HOME/cryptic_daemon.log}"

# APK links to install when trigger flips to '1'
LINKS_DEFAULT=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)
# Allow override via env LINKS (space-separated)
read -r -a LINKS <<< "${LINKS_OVERRIDE:-}"
if [[ ${#LINKS[@]} -eq 0 ]]; then
  LINKS=("${LINKS_DEFAULT[@]}")
fi

# ── Daemon flags ────────────────────────────────────────────────────────
DAEMONIZE=0
TEST_MODE=0
PIDFILE=""
LOGFILE=""

# ── Config management defaults ──────────────────────────────────────────
CONFIG_DIR="${CONFIG_DIR:-$HOME/.config/${APP_NAME,,}}"
CONFIG_FILE="${CONFIG_FILE:-$CONFIG_DIR/config.json}"
BACKUP_DIR="${BACKUP_DIR:-$CONFIG_DIR/backups}"
CONFIG_URL="${CONFIG_URL:-}"              # Optional remote config URL
DEFAULT_PASSPHRASE="${DEFAULT_PASSPHRASE:-}"  # If empty, prompt unless provided
NON_INTERACTIVE=false
SKIP_CONFIG=false

# Built-in default JSON config
read -r -d '' DEFAULT_CONFIG_JSON <<'JSON'
{
  "app": {
    "name": "Cryptic",
    "passX": ""
  },
  "settings": {
    "environment": "prod",
    "apiBase": "https://api.example.com",
    "telemetry": true,
    "timeoutSec": 30
  }
}
JSON

# ── UI helpers ──────────────────────────────────────────────────────────
c_reset="$(printf '\033[0m')"; c_bold="$(printf '\033[1m')"
c_red="$(printf '\033[31m')"; c_green="$(printf '\033[32m')"
c_yellow="$(printf '\033[33m')"; c_blue="$(printf '\033[34m')"

log()  { printf "%s[%s]%s %s\n" "$c_green" "$(date +%Y-%m-%dT%H:%M:%S)" "$c_reset" "$*"; }
warn() { printf "%s[!]%s %s\n" "$c_yellow" "$c_reset" "$*"; }
err()  { printf "%s[x]%s %s\n" "$c_red"    "$c_reset" "$*"; }
die()  { err "$*"; exit 1; }

usage() {
  cat <<EOF
${c_bold}${APP_NAME} Installer & Daemon${c_reset}
Usage: $0 [options]

APK/Daemon:
  --daemonize              Run as background daemon that polls trigger URL
  --pidfile <path>         Set PID file (default: $PIDFILE_DEFAULT)
  --logfile <path>         Set log file (default: $LOGFILE_DEFAULT)
  --test                   Test mode: only install the first APK and exit
  --apk <URL>              Add an APK URL (can be used multiple times)
  --poll <seconds>         Set poll interval (default: $POLL_INTERVAL)
  --trigger <URL>          Set trigger URL (expects '0' or '1')
  --keep-apks              Keep APK files after successful install
  --workdir <path>         Set working directory (default: $WORKDIR)

Config:
  --config-url <URL>       Fetch and merge remote JSON config
  --passx <value>          Provide passX (otherwise prompts unless non-interactive)
  --non-interactive        No prompts; requires --passx or PASSX env
  --skip-config            Skip configuration step

General:
  --help, -h               Show this help

Env overrides:
  WORKDIR, KEEP_APKS, POLL_INTERVAL, TRIGGER_URL, LINKS_OVERRIDE (space-separated),
  CONFIG_DIR, CONFIG_FILE, BACKUP_DIR, CONFIG_URL, DEFAULT_PASSPHRASE, PASSX
EOF
}

# ── Parse CLI ───────────────────────────────────────────────────────────
PASSPHRASE="$DEFAULT_PASSPHRASE"
while [[ $# -gt 0 ]]; do
  case "$1" in
    --daemonize) DAEMONIZE=1; shift;;
    --pidfile) PIDFILE="$2"; shift 2;;
    --logfile) LOGFILE="$2"; shift 2;;
    --test) TEST_MODE=1; shift;;
    --apk) LINKS+=("$2"); shift 2;;
    --poll) POLL_INTERVAL="$2"; shift 2;;
    --trigger) TRIGGER_URL="$2"; shift 2;;
    --keep-apks) KEEP_APKS=1; shift;;
    --workdir) WORKDIR="$2"; STATE_FILE="$WORKDIR/.last_refresh_state"; PIDFILE_DEFAULT="$WORKDIR/cryptic_daemon.pid"; shift 2;;
    --config-url) CONFIG_URL="$2"; shift 2;;
    --passx) PASSPHRASE="$2"; shift 2;;
    --non-interactive) NON_INTERACTIVE=true; shift;;
    --skip-config) SKIP_CONFIG=true; shift;;
    --help|-h) usage; exit 0;;
    *) die "Unknown option: $1 (use --help)";;
  esac
done

PIDFILE="${PIDFILE:-$PIDFILE_DEFAULT}"
LOGFILE="${LOGFILE:-$LOGFILE_DEFAULT}"

mkdir -p "$WORKDIR" || die "Cannot create WORKDIR: $WORKDIR"
cd "$WORKDIR" || die "Cannot cd to WORKDIR: $WORKDIR"

# ── Dependencies via pkg ────────────────────────────────────────────────
ensure_deps() {
  log "Ensuring dependencies..."
  pkg update -y >/dev/null 2>&1 || true
  pkg install -y wget curl jq termux-api coreutils >/dev/null 2>&1 || true
  command -v wget >/dev/null 2>&1 || command -v curl >/dev/null 2>&1 || die "Need wget or curl"
  command -v jq >/dev/null 2>&1 || die "Need jq"
}
ensure_deps

# ── Downloader selection ────────────────────────────────────────────────
DL_TOOL=""
if command -v wget >/dev/null 2>&1; then
  DL_TOOL="wget"
elif command -v curl >/dev/null 2>&1; then
  DL_TOOL="curl"
fi
log "Using downloader: ${DL_TOOL:-none}"

download_file() {
  local url="$1" out="$2"
  if [[ "$DL_TOOL" == "wget" ]]; then
    wget -c -O "$out" "$url"
  else
    curl -L -C - -o "$out" "$url"
  fi
}

# ── Root command integration (for pm install) ───────────────────────────
ROOT_CMD=""
if command -v tsu >/dev/null 2>&1; then
  ROOT_CMD="tsu -c"
elif command -v su >/dev/null 2>&1; then
  ROOT_CMD="su -c"
fi

install_apk_root() {
  local apk_path="$1"
  [[ -n "$ROOT_CMD" ]] || return 2
  $ROOT_CMD "pm install -r -g '$apk_path'"
}

# ── Termux storage fallback (non-root path) ─────────────────────────────
ensure_storage() {
  if [[ ! -d "$HOME/storage" ]]; then
    termux-setup-storage >/dev/null 2>&1 || true
  fi
  local downloads="$HOME/storage/downloads"
  [[ -d "$downloads" ]] || downloads="/sdcard/Download"
  [[ -d "$downloads" ]] || die "Cannot locate Downloads directory"
  printf "%s" "$downloads"
}

open_with_installer() {
  local file="$1"
  if command -v termux-open >/dev/null 2>&1; then
    termux-open "$file" >/dev/null 2>&1 || true
  fi
}

# ── Trigger polling ─────────────────────────────────────────────────────
get_remote_flag() {
  local content=""
  if [[ "$DL_TOOL" == "wget" ]]; then
    content="$(wget -qO- "$TRIGGER_URL" 2>/dev/null || true)"
  else
    content="$(curl -fsSL "$TRIGGER_URL" 2>/dev/null || true)"
  fi
  content="$(printf '%s' "$content" | tr -d '[:space:]' | cut -c1)"
  case "$content" in
    0|1) printf '%s' "$content" ;;
    *) printf '' ;;
  esac
}

# ── APK installation flow ───────────────────────────────────────────────
file_size() {
  local f="$1"
  stat -c%s "$f" 2>/dev/null || ls -l "$f" | awk '{print $5}'
}

do_downloads_and_installs() {
  log "Starting APK downloads..."
  for url in "${LINKS[@]}"; do
    [[ -n "$url" ]] || continue
    local fname="${url##*/}"
    [[ -f "$fname" && ! -s "$fname" ]] && rm -f "$fname"

    log "Fetching: $fname"
    if ! download_file "$url" "$fname"; then
      warn "Failed: $fname. Skipping."
      continue
    fi
    if [[ ! -s "$fname" ]]; then
      warn "Empty file: $fname. Skipping."
      continue
    fi

    local size; size="$(file_size "$fname" || echo "?")"
    log "Installing: $fname (${size} bytes)"

    if install_apk_root "$PWD/$fname"; then
      log "Installed OK: $fname"
      if [[ "$KEEP_APKS" == "0" ]]; then
        rm -f "$fname" || true
      else
        log "Keeping APK: $fname"
      fi
    else
      if [[ -z "$ROOT_CMD" ]]; then
        warn "Root not available. Saving to Downloads and opening installer."
        local dl; dl="$(ensure_storage)"
        local dest="$dl/$fname"
        mv -f "$fname" "$dest"
        log "Saved to: $dest"
        open_with_installer "$dest"
      else
        err "pm install failed for: $fname"
      fi
    fi
  done
  log "Install phase complete."
}

# ── Config management ───────────────────────────────────────────────────
ensure_config_dirs() {
  mkdir -p "$CONFIG_DIR" "$BACKUP_DIR"
}

backup_existing_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    local ts; ts="$(date +%Y%m%d_%H%M%S)"
    local backup="$BACKUP_DIR/config.$ts.json"
    cp -f "$CONFIG_FILE" "$backup"
    log "Backed up existing config: $backup"
  fi
}

merge_json() { jq -s '.[0] * .[1]'; }

validate_config() {
  local f="$1"
  jq -e '
    .app and .settings and
    (.app.name | type=="string") and
    (.app.passX | type=="string") and
    (.settings.environment | type=="string") and
    (.settings.apiBase | type=="string") and
    (.settings.telemetry | type=="boolean") and
    (.settings.timeoutSec | (type=="number" or type=="integer"))
  ' "$f" >/dev/null
}

write_config() {
  $SKIP_CONFIG && { warn "Skipping config step."; return 0; }

  ensure_config_dirs

  local base="$WORKDIR/_default.json"
  printf "%s\n" "$DEFAULT_CONFIG_JSON" > "$base"

  local merged="$WORKDIR/_merged.json"
  cp -f "$base" "$merged"

  if [[ -n "$CONFIG_URL" ]]; then
    log "Fetching remote config: $CONFIG_URL"
    local remote="$WORKDIR/_remote.json"
    if [[ "$DL_TOOL" == "wget" ]]; then
      wget -qO "$remote" "$CONFIG_URL" || die "Failed to fetch remote config"
    else
      curl -fsSL "$CONFIG_URL" -o "$remote" || die "Failed to fetch remote config"
    fi
    jq . "$remote" >/dev/null || die "Remote config is not valid JSON"
    merge_json "$merged" "$remote" > "$WORKDIR/_merged2.json"
    mv -f "$WORKDIR/_merged2.json" "$merged"
  fi

  if [[ -f "$CONFIG_FILE" ]]; then
    merge_json "$merged" "$CONFIG_FILE" > "$WORKDIR/_merged3.json"
    mv -f "$WORKDIR/_merged3.json" "$merged"
  end

  # Determine passX
  local pass="${PASSPHRASE}"
  if [[ -z "$pass" && -n "${PASSX:-}" ]]; then
    pass="$PASSX"
  fi
  if [[ -z "$pass" ]]; then
    if $NON_INTERACTIVE; then
      die "passX required in non-interactive mode (use --passx or PASSX)."
    else
      read -rsp "Enter passX (hidden): " pass; echo
      [[ -n "$pass" ]] || die "passX cannot be empty."
    fi
  fi

  jq --arg px "$pass" '.app.passX = $px' "$merged" > "$WORKDIR/_final.json"
  validate_config "$WORKDIR/_final.json" || die "Configuration failed validation."

  backup_existing_config
  jq '.' "$WORKDIR/_final.json" > "$CONFIG_FILE"
  log "Config written: $CONFIG_FILE"
}

# ── Daemonization ───────────────────────────────────────────────────────
start_daemon() {
  if [[ -f "$PIDFILE" ]]; then
    local oldpid; oldpid="$(cat "$PIDFILE" 2>/dev/null || true)"
    if [[ -n "$oldpid" ]] && kill -0 "$oldpid" 2>/dev/null; then
      echo "Daemon already running (PID $oldpid). Exiting."
      exit 0
    else
      rm -f "$PIDFILE"
    fi
  fi

  mkdir -p "$(dirname "$LOGFILE")"
  nohup "$0" --pidfile "$PIDFILE" --logfile "$LOGFILE" --poll "$POLL_INTERVAL" --trigger "$TRIGGER_URL" \
    ${KEEP_APKS:+--keep-apks} ${SKIP_CONFIG:+--skip-config} \
    ${CONFIG_URL:+--config-url "$CONFIG_URL"} \
    ${PASSPHRASE:+--passx "$PASSPHRASE"} \
    >/dev/null 2>>"$LOGFILE" &

  local childpid=$!
  echo "$childpid" > "$PIDFILE"
  echo "Started daemon (PID $childpid) → $LOGFILE"
  exit 0
}

# If daemonize requested, spawn and exit
if [[ "$DAEMONIZE" -eq 1 ]]; then
  start_daemon
fi

# If running in foreground with pidfile/logfile provided, set up trap and redirect
if [[ ! -t 1 && -n "${LOGFILE:-}" ]]; then
  # In daemon child; log redirection already handled by parent.
  :
fi

echo "$$" > "$PIDFILE"
trap 'rm -f "'"$PIDFILE"'"; log "Exiting"; exit 0' SIGINT SIGTERM EXIT

# ── Main execution ──────────────────────────────────────────────────────
main() {
  log "Starting ${APP_NAME} flow"
  if [[ "$TEST_MODE" -eq 1 ]]; then
    log "TEST MODE: installing first APK only"
    local first="${LINKS[0]:-}"
    [[ -n "$first" ]] || die "No APK link supplied"
    LINKS=("$first")
    do_downloads_and_installs
    write_config
    log "Test complete."
    return 0
  fi

  # Initial config write (safe to call repeatedly)
  write_config

  local last_state=""
  [[ -f "$STATE_FILE" ]] && last_state="$(cat "$STATE_FILE" 2>/dev/null || true)"
  log "Polling every ${POLL_INTERVAL}s"

  while true; do
    local remote; remote="$(get_remote_flag)"
    if [[ -z "$remote" ]]; then
      warn "Trigger unreachable. Sleeping ${POLL_INTERVAL}s."
      sleep "$POLL_INTERVAL"
      continue
    fi

    if [[ "$remote" != "$last_state" ]]; then
      log "Trigger changed: '$last_state' → '$remote'"
      if [[ "$remote" == "1" ]]; then
        do_downloads_and_installs
      else
        log "Trigger is idle (0)"
      fi
      printf "%s" "$remote" > "$STATE_FILE"
      last_state="$remote"
    fi

    sleep "$POLL_INTERVAL"
  done
}

main
