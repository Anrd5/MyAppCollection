#!/data/data/com.termux/files/usr/bin/bash
# guardian.sh — Termux automation daemon for APK, JSON, and "Other" script
# Requirements:
# - Runs continuously, hook with termux-boot
# - Installs APKs from $HOME/apks (not /sdcard/Download)
# - Replaces contents of Grow a Garden.json
# - Honors GitHub workflow-driven triggers (APK and JSON), runs once per workflow run
# - "Other" script runs only when neither APK nor JSON triggers executed in that loop
# - "Other" script does NOT run in the background and must not return exit code 0
# - Deletes APKs after successful install
# - First run: APK and JSON tasks are executed, and "Other" is skipped
# - Android 10, rooted (VMOS), Termux on Magisk

# -----------------------------
# Tunables
# -----------------------------
LOOP_SLEEP_SECONDS=600               # Continuous polling interval (10 minutes)
CURL_RETRIES=5
CURL_TIMEOUT=90

# APK URLs (direct release links)
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# JSON content URL and target
JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"
SDCARD_BASE="/storage/emulated/0"
JSON_TARGET_DIR="${SDCARD_BASE}/Cryptic/Workspace/SpeedHubX"
JSON_TARGET_FILE="${JSON_TARGET_DIR}/Grow a Garden.json"

# "Other" script (do not background; enforce non-zero return)
OTHER_LUA_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"
OTHER_LUA_PATH="/sdcard/download/reconnect.lua"

# Trigger URLs (recommend using the provided workflows below to update these files every run)
# Create these files in your repo: triggers/apk.trigger and triggers/json.trigger
APK_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/triggers/apk.trigger"
JSON_TRIGGER_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/triggers/json.trigger"

# Fallback trigger URLs (use existing workflow YAMLs if triggers/* not yet set up)
APK_TRIGGER_FALLBACK="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/.github/workflows/RefreshClones.yml"
JSON_TRIGGER_FALLBACK="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/.github/workflows/RefreshScript.yml"

# -----------------------------
# Paths and state
# -----------------------------
PREFIX="/data/data/com.termux/files/usr"
APKS_DIR="${HOME}/apks"
RUNTIME_DIR="${HOME}/.guardian"
LOG_DIR="${RUNTIME_DIR}/logs"
STATE_DIR="${RUNTIME_DIR}/state"
LOCKFILE="${RUNTIME_DIR}/guardian.lock"
LOG_FILE="${LOG_DIR}/guardian.log"

# -----------------------------
# Logging
# -----------------------------
ts() { date +"%Y-%m-%d %H:%M:%S%z"; }
log() { printf "[%s] %s\n" "$(ts)" "$*" | tee -a "${LOG_FILE}"; }
warn() { printf "[%s] WARNING: %s\n" "$(ts)" "$*" | tee -a "${LOG_FILE}" >&2; }
err() { printf "[%s] ERROR: %s\n" "$(ts)" "$*" | tee -a "${LOG_FILE}" >&2; }

# -----------------------------
# Utilities
# -----------------------------
ensure_dirs() {
  mkdir -p "${APKS_DIR}" "${RUNTIME_DIR}" "${LOG_DIR}" "${STATE_DIR}"
  chmod 700 "${RUNTIME_DIR}" "${STATE_DIR}"
}

rotate_logs() {
  [ -f "${LOG_FILE}" ] || return 0
  local sz max=524288 # 512 KiB
  sz=$(wc -c < "${LOG_FILE}" 2>/dev/null || echo 0)
  if [ "${sz}" -gt "${max}" ]; then
    mv -f "${LOG_FILE}" "${LOG_FILE}.$(date +%Y%m%d%H%M%S)"
    : > "${LOG_FILE}"
  fi
}

with_lock() {
  exec 9>"${LOCKFILE}"
  if ! flock -n 9; then
    warn "Another guardian instance is running. Exiting."
    exit 0
  fi
}

have_cmd() { command -v "$1" >/dev/null 2>&1; }

http_get() {
  # $1=url $2=outfile
  curl -fsSL --connect-timeout "${CURL_TIMEOUT}" --max-time $((CURL_TIMEOUT*2)) \
    --retry "${CURL_RETRIES}" --retry-all-errors \
    -H "Accept: */*" -o "$2" "$1"
}

http_get_text() {
  # $1=url
  curl -fsSL --connect-timeout "${CURL_TIMEOUT}" --max-time $((CURL_TIMEOUT*2)) \
    --retry "${CURL_RETRIES}" --retry-all-errors \
    -H "Accept: text/plain,*/*" "$1"
}

sha256_of() {
  # $1=path
  if have_cmd sha256sum; then
    sha256sum "$1" | awk '{print $1}'
  else
    # Busybox fallback
    if have_cmd sha256; then sha256 -q "$1"; else
      openssl dgst -sha256 "$1" | awk '{print $2}'
    fi
  fi
}

termux_storage_ready() {
  # Check if /storage/emulated/0 is accessible
  [ -d "${SDCARD_BASE}" ] && [ -w "${SDCARD_BASE}" ]
}

ensure_storage() {
  if ! termux_storage_ready; then
    warn "External storage not granted yet. Running termux-setup-storage (one-time prompt)."
    if have_cmd termux-setup-storage; then
      termux-setup-storage || warn "termux-setup-storage failed or requires user confirmation."
    else
      warn "termux-setup-storage not available."
    fi
  fi
}

first_run_needed() { [ ! -f "${STATE_DIR}/first_run_done" ]; }
mark_first_run_done() { echo "$(date -Iseconds)" > "${STATE_DIR}/first_run_done"; }

# -----------------------------
# Trigger handling
# -----------------------------
fetch_trigger_token() {
  # $1=name $2=url $3=fallback_url
  # Returns token on stdout; empty if neither reachable
  local name="$1" url="$2" fb="$3" tmp
  tmp="${STATE_DIR}/.trigger_${name}.tmp"
  if http_get "${url}" "${tmp}" 2>>"${LOG_FILE}"; then
    sha256_of "${tmp}"
  elif http_get "${fb}" "${tmp}" 2>>"${LOG_FILE}"; then
    sha256_of "${tmp}"
  else
    echo ""
  fi
  rm -f "${tmp}"
}

trigger_changed() {
  # $1=name $2=token
  local name="$1" token="$2" sf="${STATE_DIR}/trigger_${name}.last"
  [ -z "${token}" ] && return 1
  if [ -f "${sf}" ]; then
    local prev
    prev=$(cat "${sf}" 2>/dev/null || echo "")
    if [ "${token}" != "${prev}" ]; then
      echo "${token}" > "${sf}"
      return 0
    else
      return 1
    fi
  else
    # No previous token — treat as changed to run once
    echo "${token}" > "${sf}"
    return 0
  fi
}

# -----------------------------
# APK task
# -----------------------------
install_apk() {
  # $1=file
  local f="$1"
  # Try multiple install strategies
  if have_cmd pm; then
    pm install -r --grant-all-permissions --user 0 "$f" && return 0
    pm install -r "$f" && return 0
  fi
  if have_cmd cmd; then
    cmd package install -r "$f" && return 0
  fi
  return 1
}

run_apk_task() {
  log "APK: Starting download + install."
  mkdir -p "${APKS_DIR}/tmp"
  local success=0 fail=0
  for url in "${APK_URLS[@]}"; do
    local fname base tmp out
    base="$(basename "${url}")"
    fname="${base:-app-$(date +%s).apk}"
    tmp="${APKS_DIR}/tmp/${fname}.part"
    out="${APKS_DIR}/${fname}"
    log "APK: Downloading ${url}"
    if http_get "${url}" "${tmp}"; then
      mv -f "${tmp}" "${out}"
      # Basic sanity checks
      if [ ! -s "${out}" ] || [ "${out##*.}" != "apk" ]; then
        err "APK: Bad file ${out}."
        rm -f "${out}"
        fail=$((fail+1))
        continue
      fi
      log "APK: Installing ${out}"
      if install_apk "${out}"; then
        log "APK: Installed ${out}. Deleting APK."
        rm -f "${out}"
        success=$((success+1))
      else
        err "APK: Install failed for ${out}."
        fail=$((fail+1))
      fi
    else
      err "APK: Download failed for ${url}"
      rm -f "${tmp}"
      fail=$((fail+1))
    fi
  done
  rm -rf "${APKS_DIR}/tmp"
  log "APK: Completed. Success=${success} Fail=${fail}"
  [ "${success}" -gt 0 ] && return 0 || return 1
}

# -----------------------------
# JSON task
# -----------------------------
run_json_task() {
  log "JSON: Preparing to replace contents in target file."
  ensure_storage
  if ! termux_storage_ready; then
    err "JSON: External storage not available; skipping."
    return 1
  fi

  mkdir -p "${JSON_TARGET_DIR}"
  local tmp="${STATE_DIR}/SpeedHubX.Config.json.part"
  log "JSON: Downloading ${JSON_URL}"
  if ! http_get "${JSON_URL}" "${tmp}"; then
    err "JSON: Download failed."
    rm -f "${tmp}"
    return 1
  fi

  if [ ! -s "${tmp}" ]; then
    err "JSON: Empty download; aborting."
    rm -f "${tmp}"
    return 1
  fi

  # Replace contents atomically
  local tgt="${JSON_TARGET_FILE}"
  local bak="${tgt}.bak.$(date +%Y%m%d%H%M%S)"
  if [ -f "${tgt}" ]; then
    cp -f "${tgt}" "${bak}" || true
  fi
  if mv -f "${tmp}" "${tgt}"; then
    log "JSON: Replaced contents at ${tgt}"
    return 0
  else
    err "JSON: Failed to move new content into place."
    rm -f "${tmp}"
    return 1
  fi
}

# -----------------------------
# OTHER task (foreground, force non-zero exit)
# -----------------------------
run_other_task() {
  log "OTHER: Preparing reconnect.lua (foreground, non-zero exit enforced)."
  ensure_storage
  if ! termux_storage_ready; then
    err "OTHER: External storage not available; skipping."
    return 1
  fi

  # Ensure lua is available
  if ! have_cmd lua; then
    warn "OTHER: lua not found. Attempting to install."
    if have_cmd pkg; then
      yes | pkg install -y lua >/dev/null 2>&1 || warn "OTHER: Failed to install lua."
    else
      warn "OTHER: pkg command not available to install lua."
    fi
  fi
  if ! have_cmd lua; then
    err "OTHER: lua still unavailable; aborting."
    return 2
  fi

  # Download LUA script to /sdcard/download as requested
  mkdir -p "/sdcard/download"
  log "OTHER: Downloading ${OTHER_LUA_URL}"
  if ! http_get "${OTHER_LUA_URL}" "${OTHER_LUA_PATH}"; then
    err "OTHER: Download failed."
    return 3
  fi
  if [ ! -s "${OTHER_LUA_PATH}" ]; then
    err "OTHER: Downloaded file is empty."
    return 4
  fi

  # Execute in foreground
  log "OTHER: Executing lua ${OTHER_LUA_PATH}"
  lua "${OTHER_LUA_PATH}"
  local st=$?
  log "OTHER: reconnect.lua exited with code ${st}"

  # Enforce non-zero exit code for this function as requested
  if [ "${st}" -eq 0 ]; then
    warn "OTHER: Forcing non-zero exit per requirement."
    return 5
  else
    return "${st}"
  fi
}

# -----------------------------
# Main loop
# -----------------------------
main_once() {
  rotate_logs

  local did_work="false"

  # Initial run behavior
  if first_run_needed; then
    log "INIT: First run detected. Executing APK and JSON tasks."
    run_apk_task || warn "INIT: APK task had issues."
    run_json_task || warn "INIT: JSON task had issues."
    mark_first_run_done
    did_work="true"
  fi

  # Triggers
  local apk_token json_token
  apk_token="$(fetch_trigger_token "apk" "${APK_TRIGGER_URL}" "${APK_TRIGGER_FALLBACK}")"
  json_token="$(fetch_trigger_token "json" "${JSON_TRIGGER_URL}" "${JSON_TRIGGER_FALLBACK}")"

  if [ -n "${apk_token}" ] && trigger_changed "apk" "${apk_token}"; then
    log "TRIGGER: APK trigger detected."
    run_apk_task || warn "TRIGGER: APK task encountered errors."
    did_work="true"
  else
    log "TRIGGER: No APK trigger change."
  fi

  if [ -n "${json_token}" ] && trigger_changed "json" "${json_token}"; then
    log "TRIGGER: JSON trigger detected."
    run_json_task || warn "TRIGGER: JSON task encountered errors."
    did_work="true"
  else
    log "TRIGGER: No JSON trigger change."
  fi

  # OTHER runs only when neither APK nor JSON ran in this cycle
  if [ "${did_work}" = "false" ]; then
    log "OTHER: Running because no APK/JSON triggers executed this cycle."
    # Do not let non-zero exit stop the daemon loop
    if ! run_other_task; then
      warn "OTHER: Completed with non-zero exit as expected."
    fi
  else
    log "OTHER: Skipped because APK/JSON tasks executed this cycle."
  fi
}

daemon() {
  ensure_dirs
  with_lock
  log "Guardian started. PID=$$"
  while :; do
    main_once
    sleep "${LOOP_SLEEP_SECONDS}"
  done
}

daemon
