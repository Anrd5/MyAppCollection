#!/data/data/com.termux/files/usr/bin/bash
# Termux standalone automation: APK install, JSON replace, and conditional “Other” script
# Requires: curl, coreutils, bash. For APK install on rooted device: su and pm/cmd available.
# All functions run once on first start. Runs continuously. Designed for termux-boot.

set -Eeuo pipefail

# ============ CONFIG ============
# APK sources (kept in Termux private dir — not /sdcard/Download)
APK_DIR="$HOME/apks"
APK_URLS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# JSON source and target
JSON_URL="https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/SpeedHubX.Config.json"
JSON_TARGET_DIR="/storage/emulated/0/Cryptic/Workspace/SpeedHubX"
JSON_TARGET_FILE="${JSON_TARGET_DIR}/Grow a Garden.json"

# Trigger flags (these are small files the workflows will update)
TRIG_APK_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/triggers/apk.flag"
TRIG_JSON_URL="https://raw.githubusercontent.com/Anrd5/MyAppCollection/refs/heads/main/triggers/json.flag"

# “Other” script (forefront only; never background)
# Note: keep this under /sdcard so external apps can also see it if needed.
OTHER_LUA_DST="/sdcard/Download/reconnect.lua"
OTHER_LUA_URL="http://raw.reconnect-tool.top/main/v5/v5GHI789RST654kLmNoPqRsT71mM38FDluVwX321098d1fgg"

# Loop interval (seconds)
LOOP_INTERVAL=300

# State files
STATE_DIR="$HOME/.local/state/auto_runner"
mkdir -p "$STATE_DIR"
APK_HASH_FILE="$STATE_DIR/last_apk.sha256"
JSON_HASH_FILE="$STATE_DIR/last_json.sha256"
FIRST_RUN_FLAG="$STATE_DIR/.first_run"

# Logging
LOG_DIR="$HOME/.local/var/log"
mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/auto_runner.log"

# ============ UTIL ============
log() {
  printf '[%(%Y-%m-%dT%H:%M:%SZ)T] %s\n' -1 "$*" | tee -a "$LOG_FILE"
}

curl_get() {
  # Usage: curl_get <url> [output]
  # Retries with backoff, fail on HTTP errors
  local url="$1"
  shift || true
  local out="${1:-}"
  if [ -n "$out" ]; then
    curl -fsSL --connect-timeout 15 --max-time 120 --retry 5 --retry-all-errors --retry-delay 2 -o "$out" "$url"
  else
    curl -fsSL --connect-timeout 15 --max-time 120 --retry 5 --retry-all-errors --retry-delay 2 "$url"
  fi
}

sha_remote() {
  # Computes sha256 of remote resource content (returns empty on failure)
  local url="$1"
  local tmp
  tmp="$(mktemp)"
  if curl_get "$url" "$tmp"; then
    sha256sum "$tmp" | awk '{print $1}'
  else
    echo ""
  fi
  rm -f "$tmp"
}

ensure_storage() {
  # Request storage once for any /sdcard path usage
  local mark="$STATE_DIR/.storage_ready"
  if [ ! -f "$mark" ]; then
    log "Requesting storage permission (termux-setup-storage)..."
    termux-setup-storage || true
    touch "$mark"
  fi
}

have_cmd() {
  command -v "$1" >/dev/null 2>&1
}

try_install_apk() {
  # Tries multiple strategies; returns 0 on success
  local apk="$1"
  local ok=1

  # Strategy 1: root pm install (common on rooted devices)
  if have_cmd su; then
    if su -c "pm install -r --user 0 '$apk'"; then
      ok=0
    elif su -c "cmd package install -r '$apk'"; then
      ok=0
    fi
  fi

  # Strategy 2: direct pm (may work if allowed)
  if [ $ok -ne 0 ] && have_cmd pm; then
    if pm install -r "$apk"; then
      ok=0
    fi
  fi

  return $ok
}

safe_mv() {
  # Atomic-ish replace within same filesystem
  local src="$1"
  local dst="$2"
  local tmp="${dst}.tmp.$$"
  cp -f "$src" "$tmp"
  mv -f "$tmp" "$dst"
}

# ============ FIRST RUN ============
if [ ! -f "$FIRST_RUN_FLAG" ]; then
  log "First run detected: APK and JSON tasks will run once."
  touch "$FIRST_RUN_FLAG"
fi

# ============ MAIN LOOP ============
mkdir -p "$APK_DIR"

# Wake lock is optional; uncomment if you want to keep device awake during tasks:
# termux-wake-lock || true

while :; do
  ran_apk=0
  ran_json=0

  # Detect triggers or force on first run
  do_apk=0
  do_json=0

  apk_hash_remote="$(sha_remote "$TRIG_APK_URL" || true)"
  json_hash_remote="$(sha_remote "$TRIG_JSON_URL" || true)"

  if [ -f "$FIRST_RUN_FLAG" ]; then
    do_apk=1
    do_json=1
    rm -f "$FIRST_RUN_FLAG"
  else
    # Compare hashes; if empty, skip (no network or trigger missing)
    if [ -n "$apk_hash_remote" ]; then
      old_apk_hash="$(cat "$APK_HASH_FILE" 2>/dev/null || echo "")"
      if [ "$apk_hash_remote" != "$old_apk_hash" ]; then
        do_apk=1
      fi
    fi
    if [ -n "$json_hash_remote" ]; then
      old_json_hash="$(cat "$JSON_HASH_FILE" 2>/dev/null || echo "")"
      if [ "$json_hash_remote" != "$old_json_hash" ]; then
        do_json=1
      fi
    fi
  fi

  # ---------- APK TASK ----------
  if [ "$do_apk" -eq 1 ]; then
    log "APK trigger detected. Starting download + install..."
    mkdir -p "$APK_DIR"
    # Download
    for url in "${APK_URLS[@]}"; do
      name="$(basename "$url")"
      dst="$APK_DIR/$name"
      log "Downloading $name ..."
      if curl_get "$url" "$dst"; then
        log "Downloaded $name"
      else
        log "ERROR: Failed to download $name"
      fi
    done

    # Install each successfully downloaded APK
    for apk in "$APK_DIR"/*.apk; do
      [ -e "$apk" ] || continue
      name="$(basename "$apk")"
      log "Installing $name ..."
      if try_install_apk "$apk"; then
        log "Installed $name — deleting local file."
        rm -f "$apk"
      else
        log "ERROR: Failed to install $name (will keep file for inspection)."
      fi
      sleep 1
    done

    # If directory empty, remove
    rmdir "$APK_DIR" 2>/dev/null || true

    # Save new hash if we had one
    if [ -n "$apk_hash_remote" ]; then
      echo "$apk_hash_remote" > "$APK_HASH_FILE"
    fi

    ran_apk=1
    log "APK task complete."
  fi

  # ---------- JSON TASK ----------
  if [ "$do_json" -eq 1 ]; then
    log "JSON trigger detected. Replacing Grow a Garden.json ..."
    ensure_storage
    mkdir -p "$JSON_TARGET_DIR"
    tmp_json="$(mktemp)"
    if curl_get "$JSON_URL" "$tmp_json"; then
      # Ensure target exists then replace atomically
      touch "$JSON_TARGET_FILE"
      safe_mv "$tmp_json" "$JSON_TARGET_FILE"
      log "Replaced: ${JSON_TARGET_FILE}"
      # Save new hash if we had one
      if [ -n "$json_hash_remote" ]; then
        echo "$json_hash_remote" > "$JSON_HASH_FILE"
      fi
      ran_json=1
    else
      log "ERROR: Failed to download JSON from source."
    fi
    rm -f "$tmp_json" || true
  fi

  # ---------- OTHER TASK (only if neither APK nor JSON ran) ----------
  if [ "$ran_apk" -eq 0 ] && [ "$ran_json" -eq 0 ]; then
    log "No APK/JSON tasks this cycle. Running Other script in foreground..."
    ensure_storage
    other_dir="$(dirname "$OTHER_LUA_DST")"
    other_base="$(basename "$OTHER_LUA_DST")"
    mkdir -p "$other_dir"

    # Download the lua script fresh each time before running
    if curl_get "$OTHER_LUA_URL" "$OTHER_LUA_DST"; then
      # Validate non-empty file
      if [ ! -s "$OTHER_LUA_DST" ]; then
        log "ERROR: Downloaded Lua script is empty. Skipping execution."
      elif have_cmd lua; then
        log "Executing (cwd: $other_dir): lua $other_base"
        # Run from the script's directory so relative paths inside it work
        if ( cd "$other_dir" && lua "$other_base" ); then
          log "Lua script exited normally."
        else
          code=$?
          log "ERROR: Lua script exited with non-zero status ($code)."
        fi
      else
        log "ERROR: 'lua' not installed. Install with: pkg install -y lua"
      fi
    else
      log "ERROR: Failed to download Other script."
    fi
  else
    log "Other script disabled this cycle because APK/JSON task(s) ran."
  fi

  # Sleep before next poll
  log "Sleeping ${LOOP_INTERVAL}s..."
  sleep "$LOOP_INTERVAL"
done

# termux-wake-unlock || true
