#!/usr/bin/env bash
# install_cryptics_daemon.sh
# One-shot installer + daemon that polls a remote trigger file to install APKs.
# Features:
# - 8 APK links (unchanged)
# - Resume downloads (wget -c / curl -C -)
# - Silent installs via root (su -c preferred, then tsu -c), never interactive
# - KEEP_APKS support
# - CLI: --test, --daemonize, --pidfile, --logfile, --help
# - PID + state files
#
# Notes:
# - Fixes the "root:/ #" drop by ensuring all root calls are non-interactive (-c).
# - Uses a single run-as-root helper so we never accidentally spawn a root shell.
# - If both su and tsu exist, prefers su -c (Magisk) to avoid tsu variants that open shells.

set -Eeuo pipefail
IFS=$'\n\t'

# ----------------- Configuration (can be overridden with env vars) -----------------
WORKDIR="${WORKDIR:-$HOME/cryptic_apks}"
KEEP_APKS="${KEEP_APKS:-0}"                 # set KEEP_APKS=1 to keep apk files after install
POLL_INTERVAL="${POLL_INTERVAL:-30}"        # seconds between trigger checks
TRIGGER_URL="${TRIGGER_URL:-https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/RefreshClones.txt}"
STATE_FILE="${WORKDIR}/.last_refresh_state"
PIDFILE_DEFAULT="${WORKDIR}/cryptic_daemon.pid"
LOGFILE_DEFAULT="${HOME}/cryptic_daemon.log"

# ----------------- The APK links (unchanged) -----------------
LINKS=(
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/MyAppCollection/releases/download/V1.0/Cryptic.7.apk"
)

# ----------------- CLI parsing -----------------
DAEMONIZE=0
TEST_MODE=0
PIDFILE=""
LOGFILE=""

usage() {
  cat <<EOF
Usage: $0 [OPTIONS]

Options:
  --daemonize           Run as background daemon (nohup; writes PID & log)
  --pidfile <path>      PID file (default: ${PIDFILE_DEFAULT})
  --logfile <path>      Log file (default: ${LOGFILE_DEFAULT})
  --test                Download & install only the first APK once, then exit
  --help                Show this help and exit

Environment variables:
  WORKDIR, KEEP_APKS, POLL_INTERVAL, TRIGGER_URL

Examples:
  $0 --test
  $0 --daemonize
  POLL_INTERVAL=10 KEEP_APKS=1 $0 --daemonize --logfile /sdcard/cryptic_log.txt
EOF
}

i=1
while [ $i -le $# ]; do
  arg="${!i}"
  case "$arg" in
    --daemonize) DAEMONIZE=1 ;;
    --pidfile)   i=$((i+1)); PIDFILE="${!i:-}";;
    --logfile)   i=$((i+1)); LOGFILE="${!i:-}";;
    --test)      TEST_MODE=1 ;;
    --help|-h)   usage; exit 0 ;;
    *) echo "Unknown option: $arg"; usage; exit 1 ;;
  esac
  i=$((i+1))
done

PIDFILE="${PIDFILE:-$PIDFILE_DEFAULT}"
LOGFILE="${LOGFILE:-$LOGFILE_DEFAULT}"

# ----------------- Helpers -----------------
mkdir -p "$WORKDIR"
cd "$WORKDIR" || { echo "ERROR: cannot cd to $WORKDIR"; exit 1; }

log() {
  # Prefer ISO timestamp if available
  local ts
  ts="$(date --iso-8601=seconds 2>/dev/null || date)"
  printf '[%s] %s\n' "$ts" "$*"
}

# ----------------- Daemonize -----------------
if [ "$DAEMONIZE" = 1 ]; then
  # If already running, exit
  if [ -f "$PIDFILE" ]; then
    oldpid="$(cat "$PIDFILE" 2>/dev/null || true)"
    if [ -n "${oldpid:-}" ] && kill -0 "$oldpid" 2>/dev/null; then
      echo "Daemon already running (PID $oldpid). Exiting."
      exit 0
    else
      rm -f "$PIDFILE" 2>/dev/null || true
    fi
  fi
  mkdir -p "$(dirname "$LOGFILE")" 2>/dev/null || true
  nohup "$0" --pidfile "$PIDFILE" --logfile "$LOGFILE" >"$LOGFILE" 2>&1 &
  childpid=$!
  echo "$childpid" >"$PIDFILE"
  echo "Started daemon (PID $childpid). Log: $LOGFILE  PID: $PIDFILE"
  exit 0
fi

# Write our PID and ensure cleanup
printf '%s' "$$" >"$PIDFILE" 2>/dev/null || true
cleanup() {
  if [ -f "$PIDFILE" ] && [ "$(cat "$PIDFILE" 2>/dev/null || echo x)" = "$$" ]; then
    rm -f "$PIDFILE"
  fi
  log "Exiting"
}
trap cleanup SIGINT SIGTERM EXIT

# ----------------- Downloader selection -----------------
DL_TOOL=""
if command -v wget >/dev/null 2>&1; then
  DL_TOOL="wget"
elif command -v curl >/dev/null 2>&1; then
  DL_TOOL="curl"
else
  log "No wget/curl found."
  if command -v pkg >/dev/null 2>&1; then
    log "Attempting to install wget via pkg..."
    pkg update -y >/dev/null 2>&1 || true
    pkg install -y wget >/dev/null 2>&1 || true
  fi
  if command -v wget >/dev/null 2>&1; then
    DL_TOOL="wget"
  elif command -v curl >/dev/null 2>&1; then
    DL_TOOL="curl"
  else
    log "Failed to obtain wget/curl. Install one and re-run."
    exit 1
  fi
fi
log "Using downloader: $DL_TOOL"

download_file() {
  local url="$1"
  local out="$2"
  if [ "$DL_TOOL" = "wget" ]; then
    wget --tries=3 --timeout=20 -c -O "$out" "$url"
  else
    # curl: -f fail on 4xx/5xx, -L follow redirects, -C - resume, --retry
    curl -fL --retry 3 --retry-delay 2 -C - -o "$out" "$url"
  fi
}

# ----------------- Root execution (non-interactive) -----------------
ROOT_IMPL=""
if command -v su >/dev/null 2>&1; then
  ROOT_IMPL="su"     # Prefer su -c (Magisk)
elif command -v tsu >/dev/null 2>&1; then
  ROOT_IMPL="tsu"    # Fallback to tsu -c (Termux root)
else
  log "No root helper found (su/tsu). Silent installs require root."
  log "Install Magisk su or Termux tsu, then re-run."
  exit 1
fi
log "Using root helper: $ROOT_IMPL"

shell_quote() {
  # Single-quote a string for the shell, safe for paths with spaces
  # Usage: shell_quote "$var" -> outputs 'escaped'
  printf "'%s'" "$(printf "%s" "$1" | sed "s/'/'\\\\''/g")"
}

run_as_root() {
  # Always non-interactive. Never spawn an interactive root shell.
  # Usage: run_as_root "command with args"
  if [ "$ROOT_IMPL" = "su" ]; then
    su -c "$*"
  else
    # Many tsu versions support -c; using it prevents dropping into a root shell
    tsu -c "$*"
  fi
}

install_apk_root() {
  local apk_path="$1"
  local qpath
  qpath="$(shell_quote "$apk_path")"
  # Prefer 'cmd package' (Android 7+) with fallback to 'pm'
  local cmd_str="cmd package install -r -g ${qpath} || pm install -r -g ${qpath}"
  run_as_root "$cmd_str"
}

# ----------------- Trigger fetch -----------------
get_remote_flag() {
  local content=""
  if [ "$DL_TOOL" = "wget" ]; then
    content="$(wget -qO- "$TRIGGER_URL" 2>/dev/null || true)"
  else
    content="$(curl -fsSL "$TRIGGER_URL" 2>/dev/null || true)"
  fi
  content="$(printf '%s' "$content" | tr -d ' \t\r\n' | cut -c1 || true)"
  case "$content" in
    0|1) printf '%s' "$content" ;;
    *) printf '' ;;
  esac
}

# ----------------- Main work -----------------
do_downloads_and_installs() {
  log "Starting downloads and installs into $WORKDIR"
  log "----"
  for url in "${LINKS[@]}"; do
    fname="${url##*/}"

    # Clean zero-byte file if present
    if [ -f "$fname" ] && [ ! -s "$fname" ]; then
      log "Removing zero-size stale file $fname"
      rm -f "$fname"
    fi

    log "Downloading: $url"
    if ! download_file "$url" "$fname"; then
      log "Error: download failed for $fname. Skipping."
      continue
    fi

    if [ ! -s "$fname" ]; then
      log "Downloaded file is empty. Skipping install for $fname."
      continue
    fi

    # Size logging
    size_bytes="$( (stat -c%s "$fname" 2>/dev/null) || (ls -l "$fname" | awk '{print $5}') || echo "?")"
    log "Downloaded $fname (${size_bytes} bytes). Installing..."

    if install_apk_root "$PWD/$fname"; then
      log "Installed $fname successfully."
      if [ "${KEEP_APKS}" = "0" ]; then
        log "Removing $fname to save space..."
        rm -f "$fname" || true
      else
        log "Keeping $fname as requested (KEEP_APKS=1)."
      fi
    else
      rc=$?
      log "Warning: installation failed for $fname (exit $rc). File kept for debugging."
    fi
  done
  log "All tasks finished. Workdir: $WORKDIR"
}

# ----------------- TEST mode -----------------
if [ "$TEST_MODE" = 1 ]; then
  log "TEST MODE: only downloading + installing the first APK once."
  if [ ${#LINKS[@]} -gt 0 ]; then
    LINKS=("${LINKS[0]}")
  fi
  do_downloads_and_installs
  exit 0
fi

# ----------------- Daemon loop -----------------
last_state=""
if [ -f "$STATE_FILE" ]; then
  last_state="$(cat "$STATE_FILE" 2>/dev/null || true)"
fi
last_state="${last_state:-}"

log "Daemon starting. Polling $TRIGGER_URL every ${POLL_INTERVAL}s. Initial last_state='${last_state}'. Logfile: ${LOGFILE}"

while true; do
  remote="$(get_remote_flag)"
  if [ -z "$remote" ]; then
    log "Warning: could not fetch remote trigger (network issue or unexpected content). Retrying in ${POLL_INTERVAL}s."
    sleep "$POLL_INTERVAL"
    continue
  fi

  if [ "$remote" != "$last_state" ]; then
    log "Remote state changed: '${last_state}' -> '${remote}'"
    if [ "$remote" = "1" ]; then
      do_downloads_and_installs
    else
      log "Remote is '0' â€” idle."
    fi
    printf '%s' "$remote" >"$STATE_FILE"
    last_state="$remote"
  fi

  sleep "$POLL_INTERVAL"
done
